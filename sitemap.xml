# -*- coding: utf-8 -*-
#★★★設計方針1: 目的＝Flask(Web) + OR-Tools(CP-SAT)で時間割自動作成
#★★★設計方針5: schedules.py は「取得→可用コマ→制約→診断→solver→保存」の中核
# -*- coding: utf-8 -*-
from flask import (
    Blueprint, render_template, request, redirect, url_for,
    flash, make_response, session, current_app
)

import os
import sys
import math
import csv
import io
import contextlib
from collections import defaultdict

import mysql.connector

# --- Postgres対応（Render）用：psycopg2 を使える場合にだけ利用 ---
try:
    import psycopg2
    from psycopg2.extras import RealDictCursor
except Exception:
    psycopg2 = None
    RealDictCursor = None

from urllib.parse import urlparse

from ortools.sat.python import cp_model


def build_class_load_summary_solver_aligned(
    classes, timeslots, cs_weekly_map, same_time_groups,
    class_name_by_id=None, subject_name_by_id=None,
    selected_subject_rows=None,
):
    """
    作成前チェック（solver入力準拠の週コマ内訳）

    優先順：
      1) selected_subjects(group_name) を使って「同一クラス内の選択枠」を 1コマ扱いで数える
         - 同一クラス内で同じ group_name に属する科目が2つ以上ある場合のみ選択枠
         - そのメンバー科目は単コマから除外
         - 選択枠の週回数はメンバーの weekly_classes の MAX（本来は揃っている前提）

      2) selected_subject_rows が無い/空の場合のみ fallback として same_time_groups から推定
         - 同一クラス内で2科目以上になるグループを 1ブロック=1コマ扱い

    週回数混在（同一選択枠内で weekly が複数値）も mismatch_rows に積む。
    """
    class_name_by_id = class_name_by_id or {}
    subject_name_by_id = subject_name_by_id or {}

    timeslot_cnt = len(timeslots or [])

    parallel_members = set()            # (class_id, subject_id) 選択枠構成員（単コマから除外）
    blocks_by_class = defaultdict(list) # class_id -> [{tag, weekly, member_cnt}]
    mismatch_rows = []                  # 週回数混在（確定矛盾候補）

    # =========================================================
    # A) selected_subjects(group_name) が渡されている場合：最優先
    # =========================================================
    ss_groups_by_class = defaultdict(lambda: defaultdict(set))  # class_id -> group_name -> {subject_id}

    for r in (selected_subject_rows or []):
        try:
            if isinstance(r, dict):
                c_id = r.get('class_id')
                s_id = r.get('subject_id')
                g = r.get('group_name')
                sg_raw = r.get("shared_group")
            else:
                c_id = r[0] if len(r) >= 1 else None
                s_id = r[1] if len(r) >= 2 else None
                g = r[2] if len(r) >= 3 else None
                sg_raw = (r[3] if len(r) >= 4 else None)

            if c_id is None or s_id is None:
                continue
            c_id = int(c_id)
            s_id = int(s_id)

            # group_name は必須（空は“選択枠ではない”扱いにして無視）
            g = ('' if g is None else str(g)).replace('　', ' ').strip()
            if not g:
                continue

            # shared_group は “補助情報” として付ける（shared_group だけでまとめない）
            try:
                sg = int(sg_raw or 0)
            except Exception:
                sg = 0

            # group_name を主キーに。shared_group があるなら衝突防止に付け足すだけ。
            gkey = f"{g}__SG{sg}" if sg > 0 else g

            ss_groups_by_class[c_id][gkey].add(s_id)

        except Exception:
            continue

    used_selected = False




    if ss_groups_by_class:

        for c_id, gmap in ss_groups_by_class.items():
            for gname, subj_set in (gmap or {}).items():
                # 選択枠は「同一クラス内で2科目以上」が前提
                if len(subj_set) < 2:
                    continue



                members = []
                weekly_list = []
                for s_id in sorted(subj_set):
                    key = (int(c_id), int(s_id))
                    if key in (cs_weekly_map or {}):
                        w = int(cs_weekly_map.get(key, 0) or 0)
                        members.append(key)
                        weekly_list.append(w)

                if len(members) < 1:
                    continue

                used_selected = True

                ws = sorted(set(int(x) for x in weekly_list))
                if len(ws) >= 2:
                    mismatch_rows.append({
                        'gid': None,
                        'subtype': 'SS_SELECT_GROUP',
                        'class_id': int(c_id),
                        'class_name': class_name_by_id.get(int(c_id), ''),
                        'weekly_values': ws,
                        'group_name': gname,
                    })

                tag = f"SS:{gname}:c{c_id}"
                for key in members:
                    parallel_members.add(key)

                block_weekly = max(int(cs_weekly_map.get(key, 0) or 0) for key in members)
                blocks_by_class[int(c_id)].append({
                    'tag': tag,
                    'weekly': int(block_weekly),
                    'member_cnt': len(members),
                })

    # =========================================================
    # B) fallback：selected_subjects が使えない場合のみ same_time_groups
    # =========================================================
    if not used_selected:
        for g in (same_time_groups or []):
            subtype = (g.get('subtype') or '').strip() or '(blank)'
            gid = g.get('gid')

            pairs = []
            for (c_id, s_id) in (g.get('pairs') or []):
                try:
                    c_id = int(c_id)
                    s_id = int(s_id)
                except Exception:
                    continue
                if (c_id, s_id) in cs_weekly_map:
                    pairs.append((c_id, s_id))
            if not pairs:
                continue

            uniq_pairs = sorted(set(pairs))
            by_class = defaultdict(list)
            for (c_id, s_id) in uniq_pairs:
                by_class[int(c_id)].append((int(c_id), int(s_id)))

            for c_id, members in by_class.items():
                members = sorted(set(members))
                if len(members) < 2:
                    continue

                ws = sorted({int(cs_weekly_map.get(cs_key, 0) or 0) for cs_key in members})
                if len(ws) >= 2:
                    mismatch_rows.append({
                        'gid': gid,
                        'subtype': subtype,
                        'class_id': int(c_id),
                        'class_name': class_name_by_id.get(int(c_id), ''),
                        'weekly_values': ws,
                    })

                tag = f"{subtype}:{gid}:c{c_id}"
                for cs_key in members:
                    parallel_members.add(cs_key)

                block_weekly = max(int(cs_weekly_map.get(cs_key, 0) or 0) for cs_key in members)
                blocks_by_class[int(c_id)].append({
                    'tag': tag,
                    'weekly': int(block_weekly),
                    'member_cnt': len(members),
                })

    # =========================================================
    # C) クラス別集計（単コマ + 選択時間 = 合計）
    # =========================================================
    class_load_rows = []
    for c in (classes or []):
        if isinstance(c, dict):
            c_id = c.get('class_id')
            cname = c.get('class_name') or ''
        else:
            c_id = c[0] if len(c) >= 1 else None
            cname = c[1] if len(c) >= 2 else ''

        if c_id is None:
            continue
        try:
            c_id = int(c_id)
        except Exception:
            continue

        if not cname:
            cname = class_name_by_id.get(c_id, '')

        single_weekly = 0
        for (cid, sid2), w in (cs_weekly_map or {}).items():
            if int(cid) != c_id:
                continue
            if (int(cid), int(sid2)) in parallel_members:
                continue
            single_weekly += int(w or 0)

        select_weekly = sum(int(b['weekly']) for b in (blocks_by_class.get(c_id) or []))
        total = int(single_weekly) + int(select_weekly)
        gap = int(timeslot_cnt) - int(total)

        class_load_rows.append({
            'class_id': c_id,
            'class_name': cname,
            'timeslot_cnt': int(timeslot_cnt),
            'single_weekly': int(single_weekly),
            'select_weekly': int(select_weekly),
            'total_weekly': int(total),
            'gap': int(gap),
        })

    class_load_rows.sort(key=lambda r: int(r.get('class_id') or 0))
    return timeslot_cnt, class_load_rows, mismatch_rows



def normalize_same_time_groups_for_solver(same_time_groups, cs_weekly_map, logger=None):
    """
    solver に渡す same_time を安全側に正規化する。
    - (c,s) が cs_weekly_map に無いものは除外
    - 複数クラスを含むグループ（multi-class）は「科目ごと」に分割する（混線防止）
    - subtype が空でも multi-class なら class_joint 扱いに寄せる
    - gid は solver 用にユニークに振り直す
    """
    groups_in = same_time_groups or []

    # 既存 gid の最大値（新 gid の採番に使う）
    max_gid = 0
    for g in groups_in:
        try:
            max_gid = max(max_gid, int(g.get("gid") or 0))
        except Exception:
            pass
    next_gid = max_gid + 1

    out = []
    split_cnt = 0
    forced_cj = 0
    dropped = 0

    for g in groups_in:
        subtype = (g.get("subtype") or "").strip()
        gid = g.get("gid")

        # 有効ペアだけ残す
        pairs = []
        for (c_id, s_id) in (g.get("pairs") or []):
            try:
                c_id = int(c_id); s_id = int(s_id)
            except Exception:
                continue
            if (c_id, s_id) in cs_weekly_map:
                pairs.append((c_id, s_id))
        pairs = sorted(set(pairs))
        if len(pairs) < 2:
            dropped += 1
            continue

        class_ids = {c for (c, _) in pairs}
        is_multi_class = (len(class_ids) >= 2)

        # ★multi-class は「subjectごと」に分割（＝class_jointの混線を強制解除）
        if is_multi_class:
            by_subject = {}
            for (c_id, s_id) in pairs:
                by_subject.setdefault(s_id, []).append((c_id, s_id))

            for s_id, ps in by_subject.items():
                ps = sorted(set(ps))
                # 1科目だけだが 1クラスしか無いなら、合同ではないので捨てる（ノイズ）
                if len({c for (c, _) in ps}) < 2:
                    continue

                new_subtype = subtype or "class_joint"
                if not subtype:
                    forced_cj += 1

                out.append({
                    "subtype": new_subtype,
                    "gid": next_gid,
                    "pairs": ps,
                })
                next_gid += 1
                split_cnt += 1
        else:
            # single-class はそのまま（select_group / teacher_tt など）
            out.append({
                "subtype": subtype or "(blank)",
                "gid": int(gid) if gid is not None else next_gid,
                "pairs": pairs,
            })
            if gid is None:
                next_gid += 1

    if logger:
        try:
            logger.info(
                "[SAME-TIME-NORM] in=%d out=%d split=%d forced_class_joint=%d dropped=%d",
                len(groups_in), len(out), split_cnt, forced_cj, dropped
            )
        except Exception:
            pass

    return out






def _calc_class_joint_deduction(cursor, sid, weekly_map):
    """
    subtype='class_joint' の same_time を「控除コマ数」として数える（補助関数）。
    重要：weekly_map（(class_id, subject_id)->weekly_classes）は外から渡す。
          ここでは required_slots の総計や正規化処理は一切しない。
    戻り：
      (deduct_count, details)
    """
    # class_joint の group_name×subject_id → class_id集合 を作る
    cursor.execute("""
        SELECT
            c.group_name AS group_name,
            m.subject_id AS subject_id,
            m.class_id   AS class_id
        FROM constraints c
        JOIN constraint_members m ON m.constraint_id = c.id
        WHERE c.school_id = %s
          AND c.type = 'same_time'
          AND c.subtype = 'class_joint'
          AND c.group_name IS NOT NULL
    """, (sid,))
    rows = cursor.fetchall() or []

    joint_map = {}
    for r in rows:
        gname = r.get("group_name")
        s_id  = int(r["subject_id"])
        c_id  = int(r["class_id"])
        joint_map.setdefault((gname, s_id), set()).add(c_id)

    same_time_count = 0
    details = []

    # あなたが貼ったロジックはここに置く（そのままでOK）
    for (gname, s_id), class_ids in sorted(joint_map.items()):
        class_ids = sorted(class_ids)
        weeks_list = [weekly_map.get((c_id, s_id), 0) for c_id in class_ids]
        if not weeks_list:
            continue

        base = max(weeks_list)
        over = sum(weeks_list) - base
        if over <= 0:
            continue

        same_time_count += over
        details.append({
            "kind": "same_time_class_joint",
            "group_name": gname,
            "subject_id": s_id,
            "class_ids": class_ids,
            "excess_slots": over,
        })

    return same_time_count, details



#★★★設計方針2.1: スキーマ差異吸収（列の有無を見て分岐）
def _has_col(cursor, table, col):
    """列の有無チェック（MySQL/Postgres両対応）。"""
    if _db_dialect_name() == "postgresql":
        cursor.execute("""
            SELECT COUNT(*) AS n
              FROM information_schema.columns
             WHERE table_schema = current_schema()
               AND table_name   = %s
               AND column_name  = %s
        """, (table, col))
    else:
        cursor.execute("""
            SELECT COUNT(*) AS n
              FROM information_schema.COLUMNS
             WHERE TABLE_SCHEMA = DATABASE()
               AND TABLE_NAME   = %s
               AND COLUMN_NAME  = %s
        """, (table, col))

    row = cursor.fetchone() or {}
    try:
        return int(row.get("n", 0) or 0) > 0
    except Exception:
        return bool(row.get("n", 0))


#★★★設計方針3: constraints(ヘッダ)+constraint_members(明細)の縦持ちを復元する処理
#★★★設計方針4.2: subtype（class_joint/select_group/teacher_tt 等）を扱う前処理
def _load_same_time_groups_core(cursor, sid, include_subtype: bool = False):
    """
    constraints + constraint_members から same_time グループを読み込み、
    include_subtype に応じて返り値の形を変える共通ヘルパー。

    include_subtype=False:
        {constraint_id: [(class_id, subject_id), ...]}

    include_subtype=True:
        {constraint_id: {"subtype": ..., "members":[(class_id, subject_id), ...]}}
    """
    cursor.execute(
        """
        SELECT
            c.id AS constraint_id,
            c.subtype AS subtype,
            m.class_id AS class_id,
            m.subject_id AS subject_id
        FROM constraints c
        JOIN constraint_members m
          ON m.constraint_id = c.id
        WHERE c.school_id = %s
          AND c.type = 'same_time'
        ORDER BY c.id, m.class_id, m.subject_id
        """,
        (sid,),
    )
    rows = cursor.fetchall() or []

    if include_subtype:
        groups = {}  # cid -> {"subtype": str, "members": [(class_id, subject_id), ...]}
        for r in rows:
            cid = int(r["constraint_id"])
            if cid not in groups:
                groups[cid] = {"subtype": r.get("subtype"), "members": []}
            groups[cid]["members"].append((int(r["class_id"]), int(r["subject_id"])))
        return groups

    # include_subtype=False
    groups = {}  # cid -> [(class_id, subject_id), ...]
    for r in rows:
        cid = int(r["constraint_id"])
        groups.setdefault(cid, []).append((int(r["class_id"]), int(r["subject_id"])))
    return groups


def _load_same_time_groups(cursor, sid):
    # 既存の返り値仕様を維持
    return _load_same_time_groups_core(cursor, sid, include_subtype=False)


#★★★設計方針7.2: same_time グループ診断用にデータを整形（ランキング入力）
def _load_same_time_groups_for_diag(cursor, sid):
    # 既存の返り値仕様を維持（診断用）
    return _load_same_time_groups_core(cursor, sid, include_subtype=True)


#★★★設計方針6: allowed_ts_map（可用コマ）へ same_time の影響を反映（前処理）
#★★★設計方針9: 擬似固定コマ（pseudo fixed）生成の土台になり得る処理
def _apply_same_time_to_allowed_ts_map(allowed_ts_map, same_time_groups, logger=None):
    """
    allowed_ts_map に同時制約を反映する。
    - 各 same_time グループごとに、「全メンバーの共通可用スロット」を計算し、
      それをグループ全員の allowed_ts として上書きする。
    - これにより、「誰か1人でもNGなコマ」はグループ全員NGになる。
    """
    if not same_time_groups:
        return

    # logger は current_app.logger をそのまま渡してもらう想定（None ならログは無視）
    log = logger.info if logger is not None else (lambda *args, **kwargs: None)

    for cid, members in same_time_groups.items():
        # allowed_ts_map に存在するキーだけで交差をとる
        existing_keys = [
            (cls, sub)
            for (cls, sub) in members
            if (cls, sub) in allowed_ts_map
        ]

        if not existing_keys:
            # 何もキーが無い場合はスキップ
            log(
                "[same_time] constraint_id=%s は allowed_ts_map に対応キーがありません。",
                cid,
            )
            continue

        # まず最初の要素の集合を基準にする
        base_cls, base_sub = existing_keys[0]
        common_slots = set(allowed_ts_map.get((base_cls, base_sub), set()))

        # 残りと順番に共通部分をとっていく
        for cls, sub in existing_keys[1:]:
            common_slots &= set(allowed_ts_map.get((cls, sub), set()))

        # 交差結果が空 → 事実上 INFEASIBLE 候補なのでログだけ残す
         #if not common_slots:
           #  log(
          #       "[same_time] constraint_id=%s で共通可用スロットが空になりました。",
          #       cid,
           #  )

        # グループ内の全員に、同じ共通スロットをセット
        for cls, sub in existing_keys:
            allowed_ts_map[(cls, sub)] = set(common_slots)

        #log(
        #    "[same_time] constraint_id=%s に %d 個のメンバー（allowed_keys=%d）/ 共通スロット数=%d を適用しました。",
        #    cid,
        #    len(members),
        #    len(existing_keys),
        #    len(common_slots),
        #)


def _count_smart(cursor, sid, tbl: str) -> int:
    # school_id が無いテーブルは JOIN か全件フォールバック
    if _has_col(cursor, tbl, "school_id"):
        cursor.execute(f"SELECT COUNT(*) AS n FROM {tbl} WHERE school_id=%s", (sid,))
        return int((cursor.fetchone() or {}).get("n", 0))
    if tbl == "constraint_members":
        cursor.execute("""
            SELECT COUNT(*) AS n
              FROM constraint_members cm
              JOIN constraints c ON c.id = cm.constraint_id
             WHERE c.school_id = %s
        """, (sid,))
        return int((cursor.fetchone() or {}).get("n", 0))
    if tbl in ("class_subjects", "selected_subjects"):
        alias = "cs" if tbl == "class_subjects" else "ss"
        cursor.execute(f"""
            SELECT COUNT(*) AS n
              FROM {tbl} {alias}
              JOIN classes c ON c.id = {alias}.class_id
             WHERE c.school_id = %s
        """, (sid,))
        return int((cursor.fetchone() or {}).get("n", 0))
    cursor.execute(f"SELECT COUNT(*) AS n FROM {tbl}")
    return int((cursor.fetchone() or {}).get("n", 0))



#★★★設計方針5.1/7.2: 画面表示用の集計（same_time控除など）
def compute_overview(cursor, sid):
    """
    GET/POSTで共通の集計口:
      戻り値: dict(total_slots, required_slots, same_time_count, adjustment_details, per_class_req_after, periods_per_week, class_gap_list)
    """

    # --- 初期化 ---
    weekly_map = {}            # required_slots 用（選択群を1本化した後の最終マップ）
    weekly_map_cs = {}         # (class_id, subject_id) の生マップ（class_joint 控除用に保持）
    per_class_req_after = {}   # 同時化控除“後”のクラス別合計
    adjustment_details = []    # same_time 重複控除の説明用
    same_time_count = 0        # ★ここは「グループ数（TT除外）」として後段で作る想定
    class_joint_deduct_slots = 0  # ★class_joint控除“コマ数”を別管理


    # --- weekly_map 構築（選択群を1本化：group_name/shared_group を優先）---
    cs_has_school = _has_col(cursor, "class_subjects", "school_id")
    has_group = _has_col(cursor, "class_subjects", "group_name")
    has_shared = _has_col(cursor, "class_subjects", "shared_group")
    cols = [c for c in ("weekly_classes", "weekly_hours", "weekly") if _has_col(cursor, "class_subjects", c)]
    hours_expr = ("COALESCE(" + ", ".join(cols) + ", 1)") if cols else "1"

    if _has_col(cursor, "class_subjects", "class_id") and _has_col(cursor, "class_subjects", "subject_id"):
        # group_name/shared_group も取得して、同一クラス内の同一グループを“最大値1本”に束ねる
        base_sql = f"""
            SELECT
                cs.class_id,
                cs.subject_id,
                MAX({hours_expr}) AS hours
                {", TRIM(cs.group_name) AS group_name" if has_group else ""}
                {", COALESCE(cs.shared_group, 0) AS shared_group" if has_shared else ""}
            FROM class_subjects cs
            {"WHERE cs.school_id = %s" if cs_has_school else ""}
            {"GROUP BY cs.class_id, cs.subject_id, TRIM(cs.group_name), COALESCE(cs.shared_group, 0)" if (has_group or has_shared) else "GROUP BY cs.class_id, cs.subject_id"}
        """
        if cs_has_school:
            cursor.execute(base_sql, (sid,))
        else:
            # classes.school_id を使う環境
            cursor.execute(f"""
                SELECT
                    cs.class_id,
                    cs.subject_id,
                    MAX({hours_expr}) AS hours
                    {", TRIM(cs.group_name) AS group_name" if has_group else ""}
                    {", COALESCE(cs.shared_group, 0) AS shared_group" if has_shared else ""}
                FROM class_subjects cs
                JOIN classes c ON c.id = cs.class_id
                WHERE c.school_id = %s
                {"GROUP BY cs.class_id, cs.subject_id, TRIM(cs.group_name), COALESCE(cs.shared_group, 0)" if (has_group or has_shared) else "GROUP BY cs.class_id, cs.subject_id"}
            """, (sid,))

        rows = cursor.fetchall() or []

        # 1) まず (class, subject) で MAX代表（生）
        tmp_by_cs = {}
        for r in rows:
            c_id = int(r["class_id"])
            s_id = int(r["subject_id"])
            hrs  = float(r["hours"] or 0)
            key = (c_id, s_id)
            tmp_by_cs[key] = max(tmp_by_cs.get(key, 0.0), hrs)

        # ★追加：class_joint 控除用に、生の (class,subject) マップを必ず保持
        weekly_map_cs = { (c_id, s_id): int(round(hrs)) for (c_id, s_id), hrs in tmp_by_cs.items() }

        if has_group or has_shared:
            # 2) 次に、同一クラス内で group_key が同じものを「最大値1本」に集約（＝選択群の二重加算防止）
            group_max = {}  # (class_id, group_key) -> hrs

            for r in rows:
                c_id = int(r["class_id"])
                s_id = int(r["subject_id"])
                hrs  = float(r["hours"] or 0)
                hrs = max(hrs, tmp_by_cs.get((c_id, s_id), 0.0))

                gname = (r.get("group_name").strip() if has_group and r.get("group_name") else "")
                gflag = int(r.get("shared_group") or 0) if has_shared else 0
                if gname:
                    gkey = (c_id, f"G::{gname}::{gflag}")
                    group_max[gkey] = max(group_max.get(gkey, 0.0), hrs)
                else:
                    gkey = (c_id, f"S::{s_id}")
                    group_max[gkey] = max(group_max.get(gkey, 0.0), hrs)

            # 最終：required_slots 用の weekly_map（※現状のあなたの仕様のまま）
            weekly_map = {}
            for (c_id, mk), hrs in group_max.items():
                if mk.startswith("S::"):
                    s_id = int(mk.split("::", 1)[1])
                    weekly_map[(c_id, s_id)] = int(round(hrs))
                else:
                    # グループ代表：subject_id は 0 にして“グループ1本”を表す（あなたの現仕様）
                    weekly_map[(c_id, 0)] = int(round(hrs))
        else:
            # グループ列が無い場合は従来どおり
            weekly_map = { (c_id, s_id): int(round(hrs)) for (c_id, s_id), hrs in tmp_by_cs.items() }

        # =========================================================
        # ★ここが「Step2 の挿入位置」：weekly_map 確定の直後
        #    class_joint の控除は compute_overview だけで行う
        # =========================================================
        cj_deduct, cj_details = _calc_class_joint_deduction(cursor, sid, weekly_map_cs)
        class_joint_deduct_slots = int(cj_deduct or 0)
        if class_joint_deduct_slots:
            adjustment_details.extend(cj_details)


    # ↓この下に、あなたの既存の処理（total_slots算出・他subtypeの控除・per_class_req_after・return等）が続く想定

     # フォールバック：selected_subjects
    # ※ selected_subjects には weekly_classes 列が無いので、
    #    週コマ数は必ず class_subjects.weekly_classes から拾う
    if (not weekly_map
        and _has_col(cursor, "selected_subjects", "class_id")
        and _has_col(cursor, "selected_subjects", "subject_id")
        and _has_col(cursor, "class_subjects", "weekly_classes")):

        ss_has_school = _has_col(cursor, "selected_subjects", "school_id")

        if ss_has_school:
            cursor.execute(
                """
                SELECT
                    ss.class_id,
                    ss.subject_id,
                    MAX(COALESCE(cs.weekly_classes, 0)) AS hours
                FROM selected_subjects ss
                LEFT JOIN class_subjects cs
                  ON cs.school_id  = ss.school_id
                 AND cs.class_id   = ss.class_id
                 AND cs.subject_id = ss.subject_id
                WHERE ss.school_id = %s
                GROUP BY ss.class_id, ss.subject_id
                """,
                (sid,),
            )
        else:
            cursor.execute(
                """
                SELECT
                    ss.class_id,
                    ss.subject_id,
                    MAX(COALESCE(cs.weekly_classes, 0)) AS hours
                FROM selected_subjects ss
                JOIN classes c
                  ON c.class_id = ss.class_id
                LEFT JOIN class_subjects cs
                  ON cs.school_id  = c.school_id
                 AND cs.class_id   = ss.class_id
                 AND cs.subject_id = ss.subject_id
                WHERE c.school_id = %s
                GROUP BY ss.class_id, ss.subject_id
                """,
                (sid,),
            )

        rows = cursor.fetchall() or []
        for r in rows:
            c_id = int(r["class_id"])
            s_id = int(r["subject_id"])
            hrs  = int(r["hours"] or 0)
            weekly_map[(c_id, s_id)] = hrs


    # ★ class×subject 正規化（TTなどの多重を束ねる）
    by_cs_hours = {}
    for k, hours in weekly_map.items():
        if isinstance(k, tuple) and len(k) >= 2:
            cs_key = (k[0], k[1])  # (class_id, subject_id)
            prev = by_cs_hours.get(cs_key, 0.0)
            val = float(hours or 0)
            by_cs_hours[cs_key] = max(prev, val)  # “必要コマ”は最大値1本に束ねる
    hours_map = by_cs_hours

    base_total = int(sum(hours_map.values()))
    current_app.logger.info(f"[diag] normalized base_total={base_total}, cs_pairs={len(hours_map)}")



    # =========================================================
    # 選択枠（group_name）を「候補1でも1枠」として数える準備
    #  - selected_subjects の group_name 参加を枠として集計
    #  - 枠の週コマ数は weekly_map（= class_subjects由来）から取る
    # =========================================================
    cursor.execute(
        """
        SELECT class_id, group_name, subject_id
        FROM selected_subjects
        WHERE school_id = %s
          AND group_name IS NOT NULL
          AND TRIM(REPLACE(group_name, '　', '')) <> ''
        """,
        (sid,),
    )
    _ss_rows = cursor.fetchall() or []

    grouped_subjects_by_class = {}   # class_id -> set(subject_id)
    _max_in_group = {}              # (class_id, group_name) -> max(hours)

    for r in _ss_rows:
        c_id = int(r["class_id"])
        gnm = (r.get("group_name") or "").strip()
        s_id = int(r["subject_id"])

        grouped_subjects_by_class.setdefault(c_id, set()).add(s_id)

        # weekly_map は (class_id, subject_id) -> hours の想定

        h = int(weekly_map_cs.get((c_id, s_id), 0) or 0)
        key = (c_id, gnm)
        if h > int(_max_in_group.get(key, 0) or 0):
            _max_in_group[key] = h

    choice_hours_map = {}  # class_id -> choice_hours
    for (c_id, _gnm), h in _max_in_group.items():
        choice_hours_map[c_id] = int(choice_hours_map.get(c_id, 0) or 0) + int(h or 0)





    # --- same_time グループ（実ペア抽出版）-------------------------------------
    # constraint_members から (class_id, subject_id) の実ペアを作る。
    # ・class_id / subject_id の片方が NULL の場合は hours_map を用いて展開する
    #   - class_id が NULL: その subject_id を持つ全クラスの (c, s) を採用
    #   - subject_id が NULL: その class_id が持つ全科目の (c, s) を採用
    #   - 両方 NULL はスキップ
    # ・hours_map に存在しない (c, s) は無視（実需要に無いので控除対象外）
    # ・可視件数 same_time_count は subtype!='teacher_tt' をカウント
    #
    # ※このブロック内で hours_map を毎回全走査すると重くなるので、
    #   先に「科目→(c,s)一覧」「クラス→(c,s)一覧」を作って高速化する。

    # --- same_time 制約による重複控除用のグループ化 ---
    #   ※ logical_key = (種別, group_id or group_name or constraint_id)
    groups_members = {}      # logical_key -> set((c_id, s_id))
    group_subtype  = {}      # logical_key -> subtype(str)

    # hours_map から展開用インデックスを構築（高速化）
    subj_to_pairs = defaultdict(set)   # subject_id -> set((c,s))
    class_to_pairs = defaultdict(set)  # class_id   -> set((c,s))
    for (cc, ss) in (hours_map or {}).keys():
        subj_to_pairs[int(ss)].add((int(cc), int(ss)))
        class_to_pairs[int(cc)].add((int(cc), int(ss)))

    with contextlib.suppress(Exception):
        cursor.execute("""
            SELECT
                c.id          AS constraint_id,
                c.subtype     AS subtype,
                c.group_id    AS group_id,
                c.group_name  AS group_name,
                cm.class_id   AS class_id,
                cm.subject_id AS subject_id
            FROM constraints c
            JOIN constraint_members cm
              ON cm.constraint_id = c.id
            WHERE c.school_id = %s
              AND c.is_enabled = 1
              AND c.type = 'same_time'
        """, (sid,))
        rows = cursor.fetchall() or []

        # まず logical_key 単位で「生の (class_id, subject_id)」配列を作る
        raw_by_group = {}
        for r in rows:
            c_id_raw = r.get("constraint_id")
            g_id     = r.get("group_id")
            g_name   = (r.get("group_name") or "").strip()

            # group_id があればそれを最優先、なければ group_name、
            # どちらも無ければ constraint_id 単位で扱う
            if g_id is not None and str(g_id).strip() != "":
                key = ("gid", int(g_id))
            elif g_name:
                key = ("gname", g_name)
            else:
                # constraint_id が None の場合はスキップ
                if c_id_raw is None:
                    continue
                key = ("cid", int(c_id_raw))

            st = (r.get("subtype") or "").strip()
            group_subtype[key] = st
            raw_by_group.setdefault(key, []).append(
                (r.get("class_id"), r.get("subject_id"))
            )

        # NULL 補完をしつつ、hours_map に存在する (c,s) のみを集め直す
        for gkey, pairs in raw_by_group.items():
            mem = set()
            for (c_id, s_id) in pairs:
                c_val = int(c_id) if c_id is not None and str(c_id).strip() != "" else None
                s_val = int(s_id) if s_id is not None and str(s_id).strip() != "" else None

                # 両方指定あり → そのまま
                if c_val is not None and s_val is not None:
                    if (c_val, s_val) in hours_map:
                        mem.add((c_val, s_val))
                    continue

                # class_id が NULL → その科目を持つ全クラスへ展開
                if c_val is None and s_val is not None:
                    mem |= subj_to_pairs.get(s_val, set())
                    continue

                # subject_id が NULL → そのクラスが持つ全科目へ展開
                if c_val is not None and s_val is None:
                    mem |= class_to_pairs.get(c_val, set())
                    continue

                # 両方 NULL はスキップ

            # 2つ以上メンバーがあるものだけ「重複調整対象」とする
            if len(mem) >= 2:
                groups_members[gkey] = mem

    # same_time_count は「TT 以外の論理グループ」の個数
    same_time_count = sum(
        1 for gkey, mem in groups_members.items()
        if len(mem) >= 2 and (group_subtype.get(gkey) or "") != "teacher_tt"
    )

    # 控除で使うグループ（TT 含む）
    unique_groups = list(groups_members.values())




    # --- 重複控除（差分控除：合計−最大値）---
    adjusted_total = base_total
    if hours_map and unique_groups:
        for members in unique_groups:
            members = list(sorted(members))
            if len(members) <= 1:
                continue

            member_hours = [float(hours_map.get(m, 0) or 0) for m in members]
            if not any(member_hours):
                continue

            deduct = sum(member_hours) - max(member_hours)
            if deduct > 0:
                adjusted_total -= int(deduct)
                rep_idx = max(
                    range(len(member_hours)),
                    key=lambda i: member_hours[i]
                )
                rep = members[rep_idx]
                adjustment_details.append({
                    "classes": list(sorted(set(c for c, _ in members))),
                    "subjects": list(sorted(set(s for _, s in members))),
                    "representative": rep,
                    "members": members,
                    "deduct": int(deduct),
                })



        # 控除合計のログ（診断用）
        try:
            total_deduct = sum(int(d.get("deduct", 0) or 0) for d in adjustment_details)
            current_app.logger.info(
                f"[diag] same_time deduction total={total_deduct}, groups_used={len(adjustment_details)}"
            )
        except Exception:
            pass



    # --- class_joint 控除を required_slots（adjusted_total）へ反映 ---
    if class_joint_deduct_slots > 0:
        adjusted_total = max(0, int(adjusted_total) - int(class_joint_deduct_slots))
        current_app.logger.info(
            "[diag] class_joint deduct slots=%s -> adjusted_total=%s",
            str(class_joint_deduct_slots), str(adjusted_total)
        )


    # --- 重複控除“後”のクラス別合計（表示用）---
    per_class_req_after = {}
    # ① 正規化後（hours_map = class×subjectで一意化）の素の合計
    for (c_id, s_id), hrs in (hours_map or {}).items():
        per_class_req_after[c_id] = per_class_req_after.get(c_id, 0) + int(hrs or 0)
    # ② same_time（TT含む）の控除をクラス別にも反映（代表クラスに寄せる簡易法）
    try:
        for det in (adjustment_details if 'adjustment_details' in locals() else []):
            cls = det.get("classes", [])
            deduct = int(det.get("deduct", 0) or 0)
            if not deduct or not cls:
                continue
            target = cls[0]
            per_class_req_after[target] = max(0, per_class_req_after.get(target, 0) - deduct)
    except Exception:
        pass

    # --- classes × timeslots（school_id列の有無で分岐）---
    if _has_col(cursor, "classes", "school_id"):
        cursor.execute("SELECT COUNT(*) AS n FROM classes WHERE school_id=%s", (sid,))
        _cc = cursor.fetchone() or {}
    else:
        cursor.execute("SELECT COUNT(*) AS n FROM classes")
        _cc = cursor.fetchone() or {}

    if _has_col(cursor, "timeslots", "school_id"):
        cursor.execute("SELECT COUNT(*) AS n FROM timeslots WHERE school_id=%s", (sid,))
        _tc = cursor.fetchone() or {}
    else:
        cursor.execute("SELECT COUNT(*) AS n FROM timeslots")
        _tc = cursor.fetchone() or {}

    total_slots = int((_cc.get("n") or 0) * (_tc.get("n") or 0))


    # --- 1クラスあたりの週枠数（periods_per_week）---
    # timeslots 件数は直前で _tc に取得済みなので再クエリしない
    periods_per_week = int(_tc.get("n", 0) or 0)


    # --- クラス一覧（名称解決用）---
    pk_col = "id" if _has_col(cursor, "classes", "id") else ("class_id" if _has_col(cursor, "classes", "class_id") else None)
    name_candidates = ["name", "class_name", "title", "label"]
    name_col = None
    for c in name_candidates:
        if _has_col(cursor, "classes", c):
            name_col = c
            break

    rows = []
    if pk_col is not None:
        name_expr = name_col if name_col else f"CAST({pk_col} AS CHAR)"
        if _has_col(cursor, "classes", "school_id"):
            sql = f"SELECT {pk_col} AS cid, {name_expr} AS cname FROM classes WHERE school_id=%s ORDER BY {pk_col}"
            params = (sid,)
        else:
            sql = f"SELECT {pk_col} AS cid, {name_expr} AS cname FROM classes ORDER BY {pk_col}"
            params = ()
        cursor.execute(sql, params)
        rows = cursor.fetchall() or []




    # --- クラス別の“置ける最大（週の時限数）”と“不足”の診断 ---
    # --- 作成前チェック（クラス別）用：単コマ数 / 選択時間 / 合計 / 差 ---
    # ここで「候補1でも group_name を1枠」として選択時間に計上する
    class_precheck_rows = []

    # 既存ログ用（need=per_class_req_after）は残す
    class_gap_list = []

    for row in rows:
        try:
            cid = int(row.get("cid"))
        except Exception:
            continue
        cname = row.get("cname")

        # (A) 作成前チェックの合計（単コマ＋選択枠）
        grouped_set = grouped_subjects_by_class.get(cid, set())


        single_hours = 0
        for (cc, ss), hrs in (weekly_map_cs or {}).items():
            if int(cc) != int(cid):
                continue
            if int(ss) in grouped_set:
                continue
            single_hours += int(hrs or 0)


        choice_hours = int(choice_hours_map.get(cid, 0) or 0)

        total_hours = int(single_hours) + int(choice_hours)
        cap = periods_per_week
        diff = int(cap) - int(total_hours)

        class_precheck_rows.append({
            "class_id": cid,
            "class_name": cname,
            "periods_per_week": int(cap),
            "single_hours": int(single_hours),
            "choice_hours": int(choice_hours),
            "total_hours": int(total_hours),
            "diff": int(diff),
        })

        # (B) 既存の不足ログ（控除後 need）も維持
        need_after = int(per_class_req_after.get(cid, 0))
        gap = int(need_after) - int(cap)
        class_gap_list.append((cid, cname, need_after, cap, gap))





    # --- 不足が大きい順のログ（任意）---
    
    # --- 需要の最終クリップ（設計方針とは異なる提案ですが、表示を枠上限に整合させる安全弁）---
   #  try:
   #      # per_class_req_after は“正規化後＋same_time控除反映”のクラス別需要
   #      # 各クラスの需要を periods_per_week で上限クリップして合計
   #      clamped_total = 0
   #      for cid, need in (per_class_req_after or {}).items():
   #          clamped_total += min(int(need or 0), periods_per_week)

        # UI/solverに渡す required_slots は「控除後合計」と「クリップ後合計」の小さい方
        # （重複や二重登録で膨らんだ需要を、枠上限に合わせて丸める）
    #     if 'adjusted_total' in locals():
    #         before = adjusted_total
    #         adjusted_total = min(int(adjusted_total), int(clamped_total))
    #         current_app.logger.info(
    #             "[diag] clamp: adjusted_total(before)=%s -> adjusted_total(after)=%s (clamped_total=%s, periods_per_week=%s)",
    #             str(before), str(adjusted_total), str(clamped_total), str(periods_per_week)
    #         )
  #   except Exception as e:
  #       current_app.logger.info(f"[diag] clamp skipped: {e}")

    if class_gap_list:
        hot = sorted(class_gap_list, key=lambda x: x[4], reverse=True)[:10]
        for (cid, cname, need, cap, gap) in hot:
            if gap > 0:
                current_app.logger.warning(
                    "[cap] class_id=%s (%s): need=%s, cap=%s, gap=+%s",
                    cid, cname, need, cap, gap
                )

    current_app.logger.info(
        "[diag] overview: base_total=%s, adjusted_total=%s, same_time_count=%s",
        str(base_total), str(adjusted_total), str(same_time_count)
    )
    # --- 返却 ---
    return {
        "base_total": int(base_total),               # 診断用
        "required_slots": int(adjusted_total),      # ★UIが使うのは必ずこちら（控除後合計）
        "same_time_count": int(same_time_count),    # 表示用はTT除外の件数
        "total_slots": int(total_slots),
        "adjustment_details": adjustment_details,   # 追跡用
        "per_class_req_after": per_class_req_after,  # クラス別（正規化＋控除反映）
        "class_precheck_rows": class_precheck_rows
    }





# === 可用コマ / 固定コマ生成ヘルパ（Step4 用） ===
#★★★設計方針6: allowed_ts_map（可用コマ）構築（禁則/固定/TT等を反映）
def build_feasible_timeslots(
    cs_weekly_map,
    cs_teachers_map,
    team_teach_pairs,
    teacher_unavail_ts,
    timeslots,
    specific_constraints=None,
    spec_triples=None,
):
    """
    (class_id, subject_id) ごとの利用可能コマ / 固定コマを構築する。

    戻り値:
      allowed_ts_map: {(c_id, s_id): set(timeslot_id)}
      fixed_ts_map:   {(c_id, s_id): set(timeslot_id)}
    """
    # 全 timeslot_id の集合
    all_ts = {int(ts["timeslot_id"]) for ts in timeslots}
    allowed_ts_map = {}
    fixed_ts_map = {}

    # 1) 担当教師と禁則から allowed_ts_map を作成
    for (c_id, s_id), weekly in cs_weekly_map.items():
        teacher_ids = list(cs_teachers_map.get((c_id, s_id), []))

        # 担当未設定なら一旦「全コマ許可」
        if not teacher_ids:
            allowed_ts_map[(c_id, s_id)] = set(all_ts)
            continue

        is_tt = ((c_id, s_id) in team_teach_pairs)
        ok_ts = set()

        for ts_id in all_ts:
            # 各教師の「NGコマ」集合を参照
            if is_tt:
                # TT科目: 参加する全教師が OK でないと NG
                if all(ts_id not in teacher_unavail_ts.get(tid, set()) for tid in teacher_ids):
                    ok_ts.add(ts_id)
            else:
                # 通常科目: 1人でも OK な時限があれば良し
                if any(ts_id not in teacher_unavail_ts.get(tid, set()) for tid in teacher_ids):
                    ok_ts.add(ts_id)

        # 1コマも置けない場合でも、ここでは空集合として登録しておく
        allowed_ts_map[(c_id, s_id)] = ok_ts if ok_ts else set()

    # 2) specific（固定コマ）で上書き（spec_triples 優先）
    if spec_triples:
        for (c_id, s_id, ts_id) in spec_triples:
            key = (c_id, s_id)
            if key not in cs_weekly_map:
                continue
            ts_id = int(ts_id)
            fixed_ts_map.setdefault(key, set()).add(ts_id)
            allowed_ts_map[key] = {ts_id}
    elif specific_constraints:
        for row in specific_constraints:
            ts_id = row.get("timeslot_id")
            if not ts_id:
                continue
            ts_id = int(ts_id)
            for m in (row.get("members") or []):
                c_id = m.get("class_id")
                s_id = m.get("subject_id")
                if not (c_id and s_id):
                    continue
                key = (int(c_id), int(s_id))
                if key not in cs_weekly_map:
                    continue
                fixed_ts_map.setdefault(key, set()).add(ts_id)
                allowed_ts_map[key] = {ts_id}

    return allowed_ts_map, fixed_ts_map




# === クラス×科目の厳しさランキング作成ヘルパ ==========================
#★★★設計方針7.1: クラス×科目ランキング（weekly/allowed/margin）生成
def build_cs_priority_list(cs_weekly_map, allowed_ts_map):
    """
    cs_weekly_map: dict[(class_id, subject_id)] = weekly_classes
    allowed_ts_map: dict[(class_id, subject_id)] = set/list 等（利用可能コマ）
    """
    rows = []

    cs_weekly_map = cs_weekly_map or {}
    allowed_ts_map = allowed_ts_map or {}

    current_app.logger.info(
        "[DEBUG-CS-BUILD] ENTER build_cs_priority_list: cs=%s, allowed=%s",
        len(cs_weekly_map),
        len(allowed_ts_map),
    )

    for (cls, sub), weekly in cs_weekly_map.items():
        # weekly が変でも、とりあえず int にして 0 以上にする
        try:
            w = int(weekly)
            if w < 0:
                w = 0
        except (TypeError, ValueError):
            w = 0

        allowed_ts = allowed_ts_map.get((cls, sub))

        if not allowed_ts:
            allowed = 0
        elif isinstance(allowed_ts, (set, list, tuple)):
            allowed = len(allowed_ts)
        else:
            try:
                allowed = len(allowed_ts)
            except TypeError:
                try:
                    allowed = int(allowed_ts)
                except (TypeError, ValueError):
                    allowed = 0

        margin = allowed - w

        rows.append(
            {
                "class_id": cls,
                "subject_id": sub,
                "weekly": w,
                "allowed": allowed,
                "margin": margin,
            }
        )

    current_app.logger.info(
        "[DEBUG-CS-BUILD] EXIT build_cs_priority_list: rows=%s",
        len(rows),
    )

    # margin（余裕の小さい順）→ allowed（少ない順）→ weekly（多い順）
    rows.sort(key=lambda r: (r["margin"], r["allowed"], -r["weekly"]))

    return rows

# === ここまで build_cs_priority_list ====================================



# === services を絶対インポートで固定（相対は使わない） ===
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)




from services.fetchers import get_master_maps, get_constraints_normalized, split_constraints

from routes.constraints import add_soft_preferences   # ★追加（constraints.py と連携



# === Blueprint 定義（エンドポイント接頭辞: 'schedules'） ===
#schedules_bp = Blueprint(
#    "schedules",          # Blueprint 名（endpoint は 'schedules.xxx' となる）
#    __name__,
#    url_prefix="/schedules"
#)


# === ここに class_joint 用のヘルパー関数を追加 ===
def _fetch_same_time_groups_by_subtype(sid, subtype):
    """
    same_time 制約を subtype ごとに読み出し、
    constraint_id ごとの [(class_id, subject_id), ...] を返す（生SQL版）。
    """
    conn = get_db_connection()
    cursor = get_dict_cursor(conn, buffered=True)

    cursor.execute("""
        SELECT
            c.id AS constraint_id,
            cm.class_id,
            cm.subject_id
        FROM constraints AS c
        JOIN constraint_members AS cm
          ON cm.constraint_id = c.id
        WHERE c.school_id = %s
          AND c.type = 'same_time'
          AND c.is_enabled = 1
          AND c.subtype = %s
        ORDER BY c.id, cm.class_id, cm.subject_id
    """, (sid, subtype))

    groups = defaultdict(list)
    for row in (cursor.fetchall() or []):
        cid = row.get("constraint_id")
        class_id = row.get("class_id")
        subject_id = row.get("subject_id")
        if cid is None or class_id is None or subject_id is None:
            continue
        groups[int(cid)].append((int(class_id), int(subject_id)))

    try:
        cursor.close()
    except Exception:
        pass
    try:
        conn.close()
    except Exception:
        pass

    return groups



# 連続制約をDBから取る関数
def fetch_consecutive_groups(cursor, sid):
    """
    consecutive 制約（constraints + constraint_members）を生SQLで取得。
    戻り値: [
      {"constraint_id": int, "hours": int, "timeslot_id": int|None, "members":[(class_id, subject_id, teacher_id)]}
    ]
    """
    cursor.execute(
        """
        SELECT
            c.id AS constraint_id,
            c.consecutive_hours AS hours,
            c.timeslot_id AS timeslot_id,
            cm.class_id AS class_id,
            cm.subject_id AS subject_id,
            cm.teacher_id AS teacher_id
        FROM constraints AS c
        JOIN constraint_members AS cm
          ON cm.constraint_id = c.id
        WHERE c.school_id = %s
          AND c.type = 'consecutive'
          AND c.is_enabled = 1
        ORDER BY c.id ASC, cm.id ASC
        """,
        (sid,),
    )
    rows = cursor.fetchall() or []

    groups = {}
    for r in rows:
        cid = r.get("constraint_id")
        if cid is None:
            continue
        cid = int(cid)

        h = r.get("hours")
        try:
            h = int(h) if h is not None else None
        except Exception:
            h = None

        g = groups.get(cid)
        if g is None:
            g = {
                "constraint_id": cid,
                "hours": h,
                "timeslot_id": (int(r["timeslot_id"]) if r.get("timeslot_id") is not None else None),
                "members": [],
            }
            groups[cid] = g

        c_id = r.get("class_id")
        s_id = r.get("subject_id")
        t_id = r.get("teacher_id")

        if c_id is None or s_id is None:
            continue

        g["members"].append((int(c_id), int(s_id), (int(t_id) if t_id is not None else None)))

    return list(groups.values())




def _apply_class_joint_deduction(sid, demand_by_cs):
    """
    複数クラス完全同時展開（subtype='class_joint'）の same_time について、
    各グループを「1コマ扱い」にするための控除を行う。
    """
    joint_groups = _fetch_same_time_groups_by_subtype(sid, "class_joint")

    for cid, members in joint_groups.items():
        if len(members) <= 1:
            continue

        min_d = min(demand_by_cs.get(cs, 0) for cs in members)
        if min_d <= 0:
            continue

        for cs in members[1:]:
            current = demand_by_cs.get(cs, 0)
            if current <= 0:
                continue
            demand_by_cs[cs] = max(0, current - min_d)



# === Blueprint 定義（'schedules' に固定）===
#★★★設計方針5: Blueprintで画面/ルーティングを分離（配布できるWebアプリ前提）
schedules_bp = Blueprint(
    "schedules",                  # ← Blueprint名（endpointは 'schedules.xxx' になる）
    __name__,
    url_prefix="/schedules",      # /schedules/...
    template_folder="templates"   # 既存の templates をそのまま使う場合
)
#★★★設計方針2.1: MySQL利用 / 接続情報は環境変数・設定で外出し（秘匿と移植性）
def _db_dialect_name() -> str:
    """DB方言を推定（ローカルMySQL / Render Postgres 両対応）。"""
    d = (os.getenv("DB_DIALECT", "") or "").lower().strip()
    if d in ("postgres", "postgresql"):
        return "postgresql"

    url = (os.getenv("DATABASE_URL", "") or os.getenv("SQLALCHEMY_DATABASE_URI", "") or "").lower()
    if url.startswith("postgres://") or url.startswith("postgresql://"):
        return "postgresql"

    return "mysql"


def _default_sslmode_for_host(host: str) -> str:
    """ローカル(Postgres)はSSLなしが多いので host に応じて既定sslmodeを切替。
    明示指定（URLのsslmode / PGSSLMODE）がある場合はそちらが優先される。
    """
    h = (host or "").lower().strip()
    if h in ("localhost", "127.0.0.1", "::1") or h.startswith("127."):
        return "disable"
    return "require"



def _pg_connect_kwargs_from_env() -> dict:
    """Postgres接続用 kwargs を環境変数から作る（Render想定）。
    優先: DATABASE_URL / SQLALCHEMY_DATABASE_URI
    フォールバック: DB_HOST / DB_USER / DB_PASS / DB_NAME / DB_PORT
    """
    url = os.getenv("DATABASE_URL") or os.getenv("SQLALCHEMY_DATABASE_URI")
    if url:
        u = urlparse(url)
        if not u.hostname or not u.path:
            raise RuntimeError("DATABASE_URL の形式が不正です。")

        # クエリに sslmode が含まれていない場合は require を既定にする
        q = {}
        if u.query:
            for kv in u.query.split("&"):
                if not kv:
                    continue
                if "=" in kv:
                    k, v = kv.split("=", 1)
                    q[k] = v
                else:
                    q[kv] = ""
        sslmode = q.get("sslmode") or os.getenv("PGSSLMODE") or _default_sslmode_for_host(u.hostname)

        return {
            "host": u.hostname,
            "port": u.port or 5432,
            "dbname": u.path.lstrip("/"),
            "user": u.username,
            "password": u.password,
            "sslmode": sslmode,
        }

    # フォールバック（URL未設定の環境用）
    host = os.getenv("DB_HOST") or os.getenv("PGHOST")
    user = os.getenv("DB_USER") or os.getenv("PGUSER")
    password = os.getenv("DB_PASS") or os.getenv("PGPASSWORD")
    dbname = os.getenv("DB_NAME") or os.getenv("PGDATABASE")
    port = int(os.getenv("DB_PORT", os.getenv("PGPORT", "5432")))

    if not (host and user and dbname):
        raise RuntimeError("Postgres接続情報が不足しています（DATABASE_URL もしくは DB_HOST/DB_USER/DB_NAME を設定してください）。")

    sslmode = os.getenv("PGSSLMODE") or _default_sslmode_for_host(host)
    return {
        "host": host,
        "port": port,
        "dbname": dbname,
        "user": user,
        "password": password,
        "sslmode": sslmode,
    }


def get_dict_cursor(conn, buffered: bool = False):
    """dict形式でfetchできるカーソルを返す（MySQL/Postgres両対応）。"""
    if _db_dialect_name() == "postgresql":
        if RealDictCursor is None:
            raise RuntimeError("psycopg2 (RealDictCursor) が利用できません。requirements に psycopg2-binary を追加してください。")
        return conn.cursor(cursor_factory=RealDictCursor)
    return conn.cursor(dictionary=True, buffered=buffered)


def get_db_connection():
    # reset.py と同様：まず current_app.config、無ければ .env
    if _db_dialect_name() == "postgresql":
        if psycopg2 is None:
            raise RuntimeError("psycopg2 が利用できません。requirements に psycopg2-binary を追加してください。")
        return psycopg2.connect(**_pg_connect_kwargs_from_env())

    return mysql.connector.connect(**_db_config_from_app_or_env())

def _db_config_from_app_or_env():
    """
    Flaskアプリ設定 or 環境変数から、DB接続に必要なキーだけを返す。
    ※ current_app.config を丸ごと返さない（DEBUG 等が混ざって mysql.connector が落ちる）
    """
    from flask import has_app_context, current_app
    import os

    # まずは環境変数デフォルト
    cfg = {
        "host": os.getenv("DB_HOST", "localhost"),
        "user": os.getenv("DB_USER", "example_user"),
        "password": os.getenv("DB_PASS", "example_pass"),
        "database": os.getenv("DB_NAME", "example_db"),
        # "port": int(os.getenv("DB_PORT", "3306")),
    }

    # アプリコンテキスト内なら、Flask設定で上書き（DB系だけ）
    if has_app_context():
        app_cfg = current_app.config
        if app_cfg.get("DB_HOST"):
            cfg["host"] = app_cfg["DB_HOST"]
        if app_cfg.get("DB_USER"):
            cfg["user"] = app_cfg["DB_USER"]
        if app_cfg.get("DB_PASS"):
            cfg["password"] = app_cfg["DB_PASS"]
        if app_cfg.get("DB_NAME"):
            cfg["database"] = app_cfg["DB_NAME"]
        # if app_cfg.get("DB_PORT"):
        #     cfg["port"] = int(app_cfg["DB_PORT"])

    return cfg



# =========================================
# school_id の取得（session > POST/GET）
# =========================================
#★★★設計方針2.1: school_id による学校単位の分離（マルチテナント）
def _sid():
    sid = session.get("school_id")
    if sid is None:
        # フォーム or クエリでも受け付ける（数値のみ）
        try:
            sid = int(request.form.get("school_id", request.args.get("school_id", "") or 0))
        except Exception:
            sid = None
    return sid if sid and int(sid) > 0 else None



# =========================================
# 画面表示用コンテキスト作成（常に total_slots 等を返す）
# =========================================
#★★★設計方針5.1: GET表示用（現在の時間割/診断/集計を安定表示）
def build_view_context(school_id):
    ctx = {
        "teachers": [],
        "timeslots": [],
        "classes_master": [],            # ★追加
        "cell_dict": {},
        "class_cell_dict": {},           # ★互換用（= subject表示）
        "class_cell_subject_dict": {},   # ★追加（科目名表示）
        "class_cell_group_dict": {},     # ★追加（グループ名表示）
        "total_slots": 0,
        "required_slots": 0,
        "same_time_count": 0,
        "teacher_unavail_map": {},
        "weekly_list": [],
        "adjustment_details": [],
        "school_id": school_id,
        "soft_report": session.pop('soft_report', []),
    }

    if not school_id:
        return ctx

    conn = None
    cursor = None
    try:
        conn = get_db_connection()
        cursor = get_dict_cursor(conn, buffered=True)

        # 基本マスタ
        cursor.execute("SELECT * FROM classes WHERE school_id=%s ORDER BY class_name", (school_id,))
        classes = cursor.fetchall() or []
        ctx["classes_master"] = classes  # ★追加

        cursor.execute("SELECT * FROM timeslots WHERE school_id=%s ORDER BY timeslot_id", (school_id,))
        timeslots = cursor.fetchall() or []
        ctx["timeslots"] = timeslots

        total_slots = len(classes) * len(timeslots)
        ctx["total_slots"] = total_slots

        # 週コマ集計（INNER JOIN で孤立排除）
        # schedules は「存在しているのに表示が空」になる事故を避けるため、
        # masters との JOIN は LEFT JOIN で行い、欠けているマスタはプレースホルダで表示する。
        cursor.execute("""
            SELECT
                   s.teacher_id, s.timeslot_id,
                   s.class_id,   s.subject_id,
                   COALESCE(t.teacher_name, '') AS teacher_name,
                   t.number,
                   COALESCE(c.class_name, '[CLASS?]') AS class_name,
                   COALESCE(NULLIF(sub.display_name, ''), sub.subject_name, '[SUBJECT?]') AS display_name,
                   COALESCE(ts.title, '[TS?]') AS title
              FROM schedules s
              LEFT JOIN teachers  t  ON s.teacher_id  = t.teacher_id   AND t.school_id  = s.school_id
              LEFT JOIN classes   c  ON s.class_id    = c.class_id     AND c.school_id  = s.school_id
              LEFT JOIN subjects  sub ON s.subject_id = sub.subject_id AND sub.school_id = s.school_id
              LEFT JOIN timeslots ts ON s.timeslot_id = ts.timeslot_id AND ts.school_id = s.school_id
             WHERE s.school_id=%s
             ORDER BY COALESCE(t.number, 9999), s.timeslot_id
        """, (school_id,))
        schedule_rows = cursor.fetchall() or []

        # 診断ログ：保存はできているのに JOIN/表示で消えているケースを見抜く
        try:
            cursor.execute("SELECT COUNT(*) AS cnt FROM schedules WHERE school_id=%s", (school_id,))
            _cnt_row = (cursor.fetchone() or {})
            total_cnt = int(_cnt_row.get("cnt") or 0)
        except Exception:
            total_cnt = -1

        miss_teacher = sum(1 for r in schedule_rows if not (r.get("teacher_name") or "").strip())
        miss_class   = sum(1 for r in schedule_rows if (r.get("class_name") or "") in ("[CLASS?]", "", None))
        miss_subj    = sum(1 for r in schedule_rows if (r.get("display_name") or "") in ("[SUBJECT?]", "", None))
        miss_ts      = sum(1 for r in schedule_rows if (r.get("title") or "") in ("[TS?]", "", None))

        try:
            current_app.logger.info(
                "[VIEW][SCHEDULES] total=%s fetched=%s miss_teacher=%s miss_class=%s miss_subject=%s miss_timeslot=%s",
                total_cnt, len(schedule_rows), miss_teacher, miss_class, miss_subj, miss_ts
            )
        except Exception:
            pass
# ==========================================================
        # 職員時間割（teacher_id×timeslot_id）
        #  - 表示：従来どおり「クラス名+科目名」
        #  - 色：選択グルーブ（selected_subjects に group_name がある）だけ学年色
        #  - tooltip：選択グルーブなら group_name、単駒なら科目名
        # ==========================================================
        import re
        import unicodedata
        from collections import defaultdict

        # ★学年推定：class_name の先頭が全角/半角どちらでも 1/2/3 なら学年とみなす
        def _guess_grade_from_class_name(cname: str) -> int:
            s = (cname or "").replace("　", " ").strip()
            if not s:
                return 0
            # 全角数字→半角数字、全角記号→半角記号などを正規化
            s = unicodedata.normalize("NFKC", s)

            # 先頭が 1/2/3（例: "1年2組", "1-2", "１年", "２－３", "3A"）
            m = re.match(r"^\s*([1-3])", s)
            if m:
                return int(m.group(1))

            # 念のため「○年」形式も拾う（先頭が数字でない場合の保険）
            m = re.search(r"([1-3])\s*年", s)
            if m:
                return int(m.group(1))

            return 0

        # (class_id, subject_id) -> group_name（表示用）
        ss_group_map = {}
        try:
            cursor.execute("""
                SELECT class_id, subject_id, group_name
                  FROM selected_subjects
                 WHERE school_id=%s
            """, (school_id,))
            for r in (cursor.fetchall() or []):
                try:
                    c_id = int(r.get("class_id"))
                    s_id = int(r.get("subject_id"))
                except Exception:
                    continue
                g = (r.get("group_name") or "").replace("　", " ").strip()
                if not g:
                    continue
                # __SG が混ざっても表示は本体だけに寄せる
                if "__SG" in g:
                    g = g.split("__SG", 1)[0].strip()
                ss_group_map[(c_id, s_id)] = g
        except Exception:
            ss_group_map = {}

        # class_id -> grade（"1年2組" だけに依存せず、先頭 1/2/3 を拾う）
        class_grade_map = {}
        for c in (classes or []):
            cid = c.get("class_id")
            cname = c.get("class_name") or ""
            if cid is None:
                continue
            g = _guess_grade_from_class_name(cname)
            if g:
                try:
                    class_grade_map[int(cid)] = g
                except Exception:
                    pass

        cell_dict = {}
        teacher_cell_parts = defaultdict(list)      # key -> [{text,is_group,grade}, ...]
        teacher_cell_tooltips = defaultdict(list)   # key -> [tooltip_text, ...]
        _seen_text = defaultdict(set)
        _seen_tip = defaultdict(set)

        for row in (schedule_rows or []):
            try:
                t_id = int(row.get("teacher_id"))
                ts_id = int(row.get("timeslot_id"))
                c_id = int(row.get("class_id"))
                s_id = int(row.get("subject_id"))
            except Exception:
                continue

            key = (t_id, ts_id)

            cname = (row.get("class_name") or "").strip()
            sname = (row.get("display_name") or "").strip()

            # 既存表示（互換）
            vis = f"{cname}{sname}".strip()

            if vis:
                if vis not in _seen_text[key]:
                    _seen_text[key].add(vis)
                    teacher_cell_parts[key].append({
                        "text": vis,
                        "is_group": bool(ss_group_map.get((c_id, s_id), "")),
                        "grade": int(class_grade_map.get(c_id, 0) or 0),
                    })

                # 互換の cell_dict（従来の文字列）
                cell_dict[key] = f"{cell_dict[key]}, {vis}" if key in cell_dict else vis

            # tooltip（選択グルーブなら group_name）
            gname = (ss_group_map.get((c_id, s_id), "") or "").strip()
            tip_base = gname if gname else sname
            tip = f"{cname}：{tip_base}".strip() if tip_base else cname

            if tip and tip not in _seen_tip[key]:
                _seen_tip[key].add(tip)
                teacher_cell_tooltips[key].append(tip)

        ctx["cell_dict"] = cell_dict  # 互換
        ctx["teacher_cell_parts_dict"] = dict(teacher_cell_parts)
        ctx["teacher_cell_tooltip_dict"] = {k: " / ".join(v) for k, v in teacher_cell_tooltips.items()}



        # --- クラス時間割（科目名表示 / グループ名表示） ---
        class_cell_subject_dict = {}

        # ★科目名ツールチップ用
        # key=(class_id, timeslot_id) -> {subject_display_name -> set(teacher_name)}
        subject_teachers_map = defaultdict(lambda: defaultdict(set))

        # ★グループ表示（色分け）用：表示パーツを作る
        # key=(class_id, timeslot_id) -> {label -> {"is_group":bool, "grade":int, "teachers":set()}}
        group_items_map = defaultdict(
            lambda: defaultdict(lambda: {"is_group": False, "grade": 0, "teachers": set()})
        )





        def _append_cell(d, key, text):
            if not text:
                return
            if key in d:
                if text not in d[key]:
                    d[key] = f"{d[key]}, {text}"
            else:
                d[key] = text

        for row in schedule_rows:
            try:
                c_id = int(row.get("class_id"))
                ts_id = int(row.get("timeslot_id"))
                s_id = int(row.get("subject_id"))
            except Exception:
                continue

            sname = (row.get("display_name") or "").strip()
            tname = (row.get("teacher_name") or "").strip()
            tno = row.get("number")
            tlabel = str(tno) if tno is not None else ""

            key = (c_id, ts_id)
            grade = int(class_grade_map.get(c_id, 0) or 0)

            # --------------------------
            # 科目名モード：本文は（科目名 + 教員番号）
            # --------------------------
            subj_base = sname
            subj_disp = f"{subj_base}({tlabel})" if tlabel else subj_base
            _append_cell(class_cell_subject_dict, key, subj_disp)

            # ★科目名ツールチップ（科目名 -> 教員名集合）
            if subj_base:
                if tname:
                    subject_teachers_map[key][subj_base].add(tname)
                else:
                    subject_teachers_map[key][subj_base].add("")

            # --------------------------
            # グループ名モード：
            #  - group_name があれば group（色付け対象）
            #  - 無ければ単駒：display_name（色なし）
            # --------------------------
            gname = (ss_group_map.get((c_id, s_id), "") or "").strip()
            is_group = bool(gname)
            label = (gname if is_group else sname).strip()
            if not label:
                continue

            rec = group_items_map[key][label]
            # 既存が単駒でも、あとから group が来たら group 扱い優先
            rec["is_group"] = bool(rec["is_group"] or is_group)
            rec["grade"] = rec["grade"] or grade

            if is_group:
                # group のときだけ教員名を集約（単駒は表示を増やさない）
                if tname:
                    rec["teachers"].add(tname)

        # ★グループ名セル（文字列）＋★パーツ（色分け用）を組み立て
        class_cell_group_dict = {}
        class_cell_group_parts_dict = {}

        for key, itemmap in (group_items_map or {}).items():
            parts = []
            text_parts = []
            for label in sorted(itemmap.keys()):
                rec = itemmap[label]
                is_group = bool(rec.get("is_group"))
                grade = int(rec.get("grade") or 0)
                tlist = sorted({x for x in (rec.get("teachers") or set()) if x})

                if is_group and tlist:
                    txt = f"{label}（{'、'.join(tlist)}）"
                else:
                    txt = label

                parts.append({"text": txt, "is_group": is_group, "grade": grade})
                text_parts.append(txt)

            class_cell_group_parts_dict[key] = parts
            class_cell_group_dict[key] = " / ".join(text_parts)

        # ★科目名ツールチップを組み立て（科目名（教員名…））
        class_cell_subject_tooltip_dict = {}
        for key, smap in (subject_teachers_map or {}).items():
            parts = []
            for subj_base in sorted(smap.keys()):
                tset = smap.get(subj_base) or set()
                tlist = sorted({x for x in tset if x})
                if tlist:
                    parts.append(f"{subj_base}（{'、'.join(tlist)}）")
                else:
                    parts.append(subj_base)
            class_cell_subject_tooltip_dict[key] = " / ".join(parts)

        ctx["class_cell_subject_dict"] = class_cell_subject_dict
        ctx["class_cell_group_dict"] = class_cell_group_dict
        ctx["class_cell_group_parts_dict"] = class_cell_group_parts_dict  # ★追加（色分け用）
        ctx["class_cell_subject_tooltip_dict"] = class_cell_subject_tooltip_dict

        # 互換：従来の class_cell_dict は「科目名」を入れておく
        ctx["class_cell_dict"] = class_cell_subject_dict






        # 教師一覧（CSV/画面用）
        cursor.execute("SELECT * FROM teachers WHERE school_id=%s ORDER BY number", (school_id,))
        ctx["teachers"] = cursor.fetchall() or []

        return ctx

    except Exception:
        return ctx
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()




# =========================================
# same_time のユニークグループ化（school_idで限定）
# =========================================

def collect_unique_same_time_groups(cursor, school_id: int, exclude_subtype: str | None = None):
    """
    constraints + constraint_members を使って、同時刻グループをユニーク化。
    戻り値: List[ (set(class_ids), set(subject_ids)) ]
    exclude_subtype に 'teacher_tt' を渡すと、その subtype を除外する。
    """
    if _db_dialect_name() == "postgresql":
        sql = """
            SELECT
                c.id AS constraint_id,
                c.group_name,
                string_agg(DISTINCT cm.class_id::text, ',' ORDER BY cm.class_id)     AS class_ids,
                string_agg(DISTINCT cm.subject_id::text, ',' ORDER BY cm.subject_id) AS subject_ids
            FROM constraints c
            JOIN constraint_members cm
                  ON cm.constraint_id = c.id
            WHERE c.school_id = %s
              AND c.is_enabled = 1
              AND c.type = 'same_time'
              {subtype_filter}
            GROUP BY c.id, c.group_name
            ORDER BY c.id
        """
    else:
        sql = """
            SELECT
                c.id AS constraint_id,
                c.group_name,
                GROUP_CONCAT(DISTINCT cm.class_id ORDER BY cm.class_id)     AS class_ids,
                GROUP_CONCAT(DISTINCT cm.subject_id ORDER BY cm.subject_id) AS subject_ids
            FROM constraints c
            JOIN constraint_members cm
                  ON cm.constraint_id = c.id
            WHERE c.school_id = %s
              AND c.is_enabled = 1
              AND c.type = 'same_time'
              {subtype_filter}
            GROUP BY c.id, c.group_name
            ORDER BY c.id
        """
    # exclude_subtype が指定されている場合だけ除外句を付与
    subtype_filter = ""
    params = [school_id]
    if exclude_subtype:
        subtype_filter = "AND (c.subtype IS NULL OR c.subtype <> %s)"
        sql = sql.format(subtype_filter=subtype_filter)
        params.append(exclude_subtype)
    else:
        sql = sql.format(subtype_filter="")

    cursor.execute(sql, tuple(params))
    rows = cursor.fetchall() or []

    result, seen = [], set()
    for r in rows:
        cls_s = r.get("class_ids") or ""
        sub_s = r.get("subject_ids") or ""
        if not cls_s or not sub_s:
            continue
        class_ids = set(int(x) for x in cls_s.split(",") if x.strip().isdigit())
        subject_ids = set(int(x) for x in sub_s.split(",") if x.strip().isdigit())
        key = (tuple(sorted(class_ids)), tuple(sorted(subject_ids)))
        if class_ids and subject_ids and key not in seen:
            seen.add(key)
            result.append((class_ids, subject_ids))
    return result
# 末尾行（この行まで置換）






def fetch_same_time_groups(cursor, sid):
    """
    same_time を安全に復元して返す（混線防止版）

    returns: list[dict]
      {
        "subtype": str,
        "gid": int,          # 基本は group_id を使うが、混線検出時は constraint_id に差し替える
        "pairs": [(class_id, subject_id), ...]
      }

    方針:
      1) subtype を跨いで混ぜない（キーは (subtype, gid)）
      2) class_joint / teacher_tt で「同一クラス内に複数科目」が出たら group_id が衝突混線している可能性が高いので、
         その行は constraint_id 単位に分割して gid も constraint_id に差し替える（下流で再合流しないため）
    """
    cursor.execute(
        """
        SELECT
            c.id AS constraint_id,
            COALESCE(NULLIF(TRIM(c.subtype), ''), '') AS subtype,
            COALESCE(NULLIF(c.group_id, 0), c.id) AS gid,
            cm.class_id AS class_id,
            cm.subject_id AS subject_id
        FROM constraints c
        JOIN constraint_members cm
          ON cm.constraint_id = c.id
        WHERE c.school_id = %s
          AND c.is_enabled = 1
          AND c.type = 'same_time'
          AND cm.class_id IS NOT NULL
          AND cm.subject_id IS NOT NULL
        ORDER BY c.id, cm.class_id, cm.subject_id
        """,
        (sid,),
    )
    rows = cursor.fetchall() or []

    def _get(r, key, idx, default=None):
        if isinstance(r, dict):
            return r.get(key, default)
        try:
            return r[idx]
        except Exception:
            return default

    groups_map = {}   # key -> {"subtype","gid","pairs"}
    class_seen = {}   # (subtype,gid) -> {class_id: subject_id}（混線検出用）
    gid_to_subtypes = {}  # gid -> set(subtype)（診断用）
    split_count = 0

    # 「同一クラス内に複数科目」が原理的に起きにくい subtype
    # ※あなたのログで混線していたのは class_joint なので最低限これだけ入れる
    SPLIT_ON_CLASS_DUP = {"class_joint", "teacher_tt"}

    for r in rows:
        constraint_id = _get(r, "constraint_id", 0, None)
        subtype = (_get(r, "subtype", 1, "") or "").strip()
        gid_raw = _get(r, "gid", 2, None)

        class_id = _get(r, "class_id", 3, None)
        subject_id = _get(r, "subject_id", 4, None)

        if constraint_id is None or class_id is None or subject_id is None:
            continue

        try:
            constraint_id = int(constraint_id)
            class_id = int(class_id)
            subject_id = int(subject_id)
        except Exception:
            continue

        # gid は基本 group_id（無ければ constraint_id）
        try:
            gid = int(gid_raw) if gid_raw is not None else int(constraint_id)
        except Exception:
            gid = int(constraint_id)

        # gid が複数 subtype に使われているか（診断用）
        gid_to_subtypes.setdefault(gid, set()).add(subtype or "(blank)")

        base_key = (subtype, gid)
        use_key = base_key
        use_gid = gid

        # --- 混線検出：class_joint/teacher_tt で同一クラスに別subjectが来たら分割 ---
        if subtype in SPLIT_ON_CLASS_DUP:
            seen = class_seen.setdefault(base_key, {})
            prev = seen.get(class_id)
            if prev is not None and prev != subject_id:
                # group_id が衝突混線している可能性が高いので constraint_id 単位に分割
                use_key = (subtype, gid, constraint_id)
                use_gid = constraint_id  # ★gid も差し替えて下流で再合流しないようにする
                split_count += 1
            else:
                seen[class_id] = subject_id

        g = groups_map.get(use_key)
        if g is None:
            g = {"subtype": subtype, "gid": int(use_gid), "pairs": []}
            groups_map[use_key] = g

        g["pairs"].append((class_id, subject_id))

    # 仕上げ（重複排除）
    groups = []
    for g in groups_map.values():
        uniq = sorted(set(g.get("pairs") or []))
        if not uniq:
            continue
        g["pairs"] = uniq
        groups.append(g)


    # =========================================================
    # ★selected_subjects(group_name) から select_group を復元（constraints側の select_group を差し替え）
    #   - 総合学科の選択枠は group_name が正（constraints由来は補助/旧データになりやすい）
    #   - group_name が空の行は選択枠ではない扱い
    # =========================================================
    try:
        cursor.execute(
            '''
            SELECT class_id, subject_id, group_name, shared_group
            FROM selected_subjects
            WHERE school_id=%s
              AND class_id IS NOT NULL
              AND subject_id IS NOT NULL
            ''',
            (sid,),
        )
        _ss_rows = cursor.fetchall() or []
    except Exception:
        _ss_rows = []

    if _ss_rows:
        # constraints 由来の select_group は一旦除外し、selected_subjects で再構成する
        removed = 0
        _tmp = []
        for g in (groups or []):
            if (g.get("subtype") or "").strip() == "select_group":
                removed += 1
                continue
            _tmp.append(g)
        groups = _tmp

        from collections import defaultdict as _dd
        ss_groups = _dd(lambda: _dd(set))  # class_id -> gkey -> {subject_id}
        for r in (_ss_rows or []):
            try:
                if isinstance(r, dict):
                    c_id = r.get("class_id")
                    s_id = r.get("subject_id")
                    g = r.get("group_name")
                    sg_raw = r.get("shared_group")
                else:
                    c_id = r[0] if len(r) >= 1 else None
                    s_id = r[1] if len(r) >= 2 else None
                    g = r[2] if len(r) >= 3 else None
                    sg_raw = (r[3] if len(r) >= 4 else None)

                if c_id is None or s_id is None:
                    continue
                c_id = int(c_id)
                s_id = int(s_id)

                g = ("" if g is None else str(g)).replace("　", " ").strip()
                if not g:
                    continue

                try:
                    sg = int(sg_raw or 0)
                except Exception:
                    sg = 0

                # group_name を主キーに。shared_group があれば衝突防止に付け足すだけ。
                gkey = f"{g}__SG{sg}" if sg > 0 else g
                ss_groups[c_id][gkey].add(s_id)

            except Exception:
                continue

        added_groups = 0
        added_pairs = 0
        next_gid = max([int(g.get("gid") or 0) for g in (groups or [])] + [0]) + 1

        for c_id, gmap in (ss_groups or {}).items():
            for gkey, subj_set in (gmap or {}).items():
                if len(subj_set) < 2:
                    continue

                pairs = []
                for s_id in sorted(subj_set):
                    pairs.append((int(c_id), int(s_id)))

                if len(pairs) < 2:
                    continue

                groups.append({
                    "subtype": "select_group",
                    "gid": int(next_gid),
                    "pairs": pairs,
                    "group_name": gkey,  # ★表示/タグ用（下流で使える）
                })
                added_groups += 1
                added_pairs += len(pairs)
                next_gid += 1

        try:
            from flask import current_app
            current_app.logger.info(
                "[SAME-TIME][SS] replaced_select_group removed=%d added_groups=%d pairs=%d",
                removed, added_groups, added_pairs
            )
        except Exception:
            pass

    # 任意ログ（壊れたgidの気配が出る）
    try:
        from flask import current_app
        bad = [(gid, sorted(list(sts))) for gid, sts in gid_to_subtypes.items() if len(sts) >= 2]
        if bad:
            current_app.logger.warning("[SAME-TIME][WARN] same gid used by multiple subtypes: %s", bad[:10])
        if split_count:
            current_app.logger.warning("[SAME-TIME][SPLIT] split_by_constraint=%d", split_count)
        current_app.logger.info("[SAME-TIME] groups=%d rows=%d", len(groups), len(rows))
    except Exception:
        pass

    return groups






def add_consecutive_hard(
    model,
    subject_in_slot,
    timeslots,
    cs_weekly_map,
    allowed_ts_map,
    consecutive_groups,
    logger=None,
):
    """
    consecutive を「少なくとも1回、k連続が存在する」ハード制約として貼る。
    - timeslot の隣接判定：同一曜日 & number連番 & 休み時間が長すぎない
      （昼休みをまたぐ 4→5 を連続扱いしない目的）
    """
    # --- 隣接の許容ギャップ（分）: 通常休憩10分はOK / 昼休み60分はNG になる想定
    CONSECUTIVE_MAX_GAP_MIN = 20

    def _time_to_min(x):
        if x is None:
            return None
        # datetime.time の場合
        try:
            return int(x.hour) * 60 + int(x.minute)
        except Exception:
            pass
        # "HH:MM:SS" の場合
        try:
            s = str(x)
            hh, mm = s.split(":")[0], s.split(":")[1]
            return int(hh) * 60 + int(mm)
        except Exception:
            return None

    # timeslot_id -> meta
    ts_meta = {}
    for ts in (timeslots or []):
        try:
            ts_id = int(ts["timeslot_id"])
        except Exception:
            continue
        day = str(ts.get("day_of_week") or "")
        num = int(ts.get("number") or 0)
        st = _time_to_min(ts.get("start_time"))
        en = _time_to_min(ts.get("end_time"))
        ts_meta[ts_id] = {"day": day, "num": num, "st": st, "en": en}

    # day -> sorted ts_ids
    day_to_ts = {}
    for ts_id, m in ts_meta.items():
        day_to_ts.setdefault(m["day"], []).append(ts_id)
    for day in day_to_ts:
        day_to_ts[day].sort(key=lambda tid: ts_meta[tid]["num"])

    def _is_adj(a_id, b_id):
        a = ts_meta[a_id]
        b = ts_meta[b_id]
        if a["day"] != b["day"]:
            return False
        if b["num"] != a["num"] + 1:
            return False
        if a["en"] is None or b["st"] is None:
            # 時刻が取れない場合は number 連番だけで連続扱い
            return True
        gap = b["st"] - a["en"]
        return gap <= CONSECUTIVE_MAX_GAP_MIN

    def _windows_of_k(k, fixed_start_ts_id=None):
        wins = []
        for day, ids in day_to_ts.items():
            n = len(ids)
            for i in range(0, n - k + 1):
                w = ids[i : i + k]
                ok = True
                for j in range(k - 1):
                    if not _is_adj(w[j], w[j + 1]):
                        ok = False
                        break
                if not ok:
                    continue
                if fixed_start_ts_id is not None and w[0] != fixed_start_ts_id:
                    continue
                wins.append(w)
        return wins

    applied = 0
    skipped = 0
    forced_bad = 0

    for g in (consecutive_groups or []):
        cid = g.get("constraint_id")
        k = g.get("hours")
        try:
            k = int(k) if k is not None else None
        except Exception:
            k = None

        if not k or k < 2:
            skipped += 1
            continue

        fixed_start = g.get("timeslot_id", None)
        wins_all = _windows_of_k(k, fixed_start_ts_id=fixed_start)

        for (c_id, s_id, _t_id) in (g.get("members") or []):
            cs_key = (int(c_id), int(s_id))
            if cs_key not in cs_weekly_map:
                skipped += 1
                continue

            weekly = int(cs_weekly_map.get(cs_key, 0))
            if weekly < k:
                # そもそも週コマが足りない → 必ず不可能
                if logger:
                    logger.warning("[CONSEC][BAD] cid=%s cs=%s weekly=%s < k=%s", cid, cs_key, weekly, k)
                model.Add(0 == 1)
                forced_bad += 1
                continue

            allowed_set = set(allowed_ts_map.get(cs_key, []) or []) if allowed_ts_map else None

            start_bools = []
            for w in wins_all:
                # allowed_ts_map で不可能な窓は捨てる（探索を軽くする）
                if allowed_set is not None:
                    ok = True
                    for ts_id in w:
                        if ts_id not in allowed_set:
                            ok = False
                            break
                    if not ok:
                        continue

                # 変数が無い窓は捨てる
                vars_in_w = []
                ok = True
                for ts_id in w:
                    v = subject_in_slot.get((cs_key[0], cs_key[1], int(ts_id)))
                    if v is None:
                        ok = False
                        break
                    vars_in_w.append(v)
                if not ok:
                    continue

                b = model.NewBoolVar(f"cons_c{cs_key[0]}_s{cs_key[1]}_cid{cid}_st{w[0]}")
                for v in vars_in_w:
                    model.Add(v == 1).OnlyEnforceIf(b)
                start_bools.append(b)

            if not start_bools:
                # 窓が0 → 連続を満たす配置が存在しない
                if logger:
                    logger.warning("[CONSEC][BAD] cid=%s cs=%s k=%s windows=0", cid, cs_key, k)
                model.Add(0 == 1)
                forced_bad += 1
                continue

            # 「少なくとも1回 k連続が存在する」
            model.Add(sum(start_bools) >= 1)
            applied += 1

            # weekly==k の場合は「ちょうど1回の連続ブロック」に絞ると安定しやすい
            if weekly == k:
                model.Add(sum(start_bools) == 1)

            if logger:
                logger.info("[CONSEC] cid=%s cs=%s weekly=%s k=%s windows=%s", cid, cs_key, weekly, k, len(start_bools))

    if logger:
        logger.info("[CONSEC-SUMMARY] applied=%d skipped=%d forced_bad=%d", applied, skipped, forced_bad)



def build_class_joint_groups_by_subject(same_time_groups, cs_weekly_map):
    """
    subtype=class_joint のグループを「科目ごと」に分割して返す。
    returns: list[list[(class_id, subject_id), ...]]
    """
    out = []
    for g in (same_time_groups or []):
        if (g.get("subtype") or "").strip() != "class_joint":
            continue

        pairs = [(int(c), int(s)) for (c, s) in (g.get("pairs") or [])]
        pairs = [(c, s) for (c, s) in pairs if (c, s) in cs_weekly_map]  # 実在講座だけ

        by_sub = defaultdict(list)
        for c, s in pairs:
            by_sub[s].append((c, s))

        for s, members in by_sub.items():
            if len(members) >= 2:
                out.append(sorted(members))
    return out


#★★★設計方針5.1/4.2: same_time をハード制約として solver に貼る（subtypeで貼り方が変わる）
def add_same_time_hard(model, subject_in_slot, cs_weekly_map, timeslots, same_time_groups, logger=None):
    """
    same_time をハード制約で一致させる（1回だけ適用）
      - class_joint: 科目ごとに分割して (class間) 同期
      - それ以外: クラスごとに分割して (同一クラス内の複数科目) 同期 ← 芸術Ⅰはこちら
    """
    ts_ids = [int(ts["timeslot_id"]) for ts in (timeslots or []) if ts.get("timeslot_id") is not None]

    applied_groups = 0
    applied_eq = 0

    for g in (same_time_groups or []):
        subtype = (g.get("subtype") or "").strip()
        pairs = [(int(c), int(s)) for (c, s) in (g.get("pairs") or [])]
        pairs = [(c, s) for (c, s) in pairs if (c, s) in cs_weekly_map]  # 実在だけ
        if len(pairs) < 2:
            continue

        if subtype == "class_joint":
            by_sub = defaultdict(list)
            for (c, s) in pairs:
                by_sub[s].append((c, s))
            for s, sub_pairs in by_sub.items():
                if len(sub_pairs) < 2:
                    continue
                rep_c, rep_s = sub_pairs[0]
                for (c, ss) in sub_pairs[1:]:
                    for ts_id in ts_ids:
                        k1 = (rep_c, rep_s, ts_id)
                        k2 = (c, ss, ts_id)
                        if k1 in subject_in_slot and k2 in subject_in_slot:
                            model.Add(subject_in_slot[k1] == subject_in_slot[k2])
                            applied_eq += 1
                applied_groups += 1

        else:
            # ★芸術Ⅰ：同一クラス内で複数科目を同じ時限に揃える
            by_class = defaultdict(list)
            for (c, s) in pairs:
                by_class[c].append((c, s))
            for c, cls_pairs in by_class.items():
                if len(cls_pairs) < 2:
                    continue
                rep_c, rep_s = cls_pairs[0]
                for (cc, s) in cls_pairs[1:]:
                    for ts_id in ts_ids:
                        k1 = (rep_c, rep_s, ts_id)
                        k2 = (cc, s, ts_id)
                        if k1 in subject_in_slot and k2 in subject_in_slot:
                            model.Add(subject_in_slot[k1] == subject_in_slot[k2])
                            applied_eq += 1
                applied_groups += 1

    if logger:
        try:
            logger.info("[SAME-TIME-HARD] applied_groups=%d applied_eq=%d", applied_groups, applied_eq)
        except Exception:
            pass

    return applied_groups, applied_eq


def apply_same_time_to_allowed_ts_map_minimal(allowed_ts_map, same_time_groups, cs_weekly_map, logger=None):
    """
    （任意・切り分け用）
    allowed_ts_map を same_time の積集合で絞る。バグ切り分けでは False 推奨。
    """
    changed = 0

    for g in (same_time_groups or []):
        subtype = (g.get("subtype") or "").strip()
        pairs = [(int(c), int(s)) for (c, s) in (g.get("pairs") or [])]
        pairs = [(c, s) for (c, s) in pairs if (c, s) in cs_weekly_map]
        if len(pairs) < 2:
            continue

        if subtype == "class_joint":
            # 科目ごと
            by_sub = defaultdict(list)
            for c, s in pairs:
                by_sub[s].append((c, s))
            for s, members in by_sub.items():
                if len(members) < 2:
                    continue
                inter = None
                for cs_key in members:
                    ts_set = set(allowed_ts_map.get(cs_key, []) or [])
                    inter = ts_set if inter is None else (inter & ts_set)
                inter = inter or set()
                for cs_key in members:
                    before = set(allowed_ts_map.get(cs_key, []) or [])
                    after = before & inter
                    if after != before:
                        allowed_ts_map[cs_key] = sorted(after)
                        changed += 1
        else:
            # クラスごと（芸術Ⅰ）
            by_class = defaultdict(list)
            for c, s in pairs:
                by_class[c].append((c, s))
            for c, members in by_class.items():
                if len(members) < 2:
                    continue
                inter = None
                for cs_key in members:
                    ts_set = set(allowed_ts_map.get(cs_key, []) or [])
                    inter = ts_set if inter is None else (inter & ts_set)
                inter = inter or set()
                for cs_key in members:
                    before = set(allowed_ts_map.get(cs_key, []) or [])
                    after = before & inter
                    if after != before:
                        allowed_ts_map[cs_key] = sorted(after)
                        changed += 1

    if logger:
        try:
            logger.info("[SAME-TIME-ALLOWED] changed=%d", changed)
        except Exception:
            pass

    return changed





def build_class_load_summary(classes, timeslots, cs_weekly_map, same_time_groups):
    """
    クラス別に
      - 時限数（週の総コマ = timeslots数）
      - 単コマ数（select_group以外の weekly 合計）
      - 選択時間（select_groupに属する weekly 合計）
    を集計して返す
    """
    ts_cnt = len(timeslots or [])

    # --- select_group に属する (class_id, subject_id) を抽出 ---
    select_pairs = set()
    for g in (same_time_groups or []):
        subtype = (g.get("subtype") or "").strip()
        if subtype != "select_group":
            continue

        members = g.get("pairs")
        if not members:
            members = g.get("members")  # dict形式も拾う
        members = members or []

        for m in members:
            if isinstance(m, (tuple, list)) and len(m) >= 2:
                cid, sid = m[0], m[1]
            elif isinstance(m, dict):
                cid, sid = m.get("class_id"), m.get("subject_id")
            else:
                continue

            if cid is None or sid is None:
                continue
            select_pairs.add((int(cid), int(sid)))

    # --- クラス別集計 ---
    rows = []
    for c in (classes or []):
        cid = int(c.get("class_id"))
        cname = c.get("class_name") or c.get("name") or f"class#{cid}"

        single_weekly = 0
        select_weekly = 0

        for (cc, ss), w in (cs_weekly_map or {}).items():
            if int(cc) != cid:
                continue
            w = int(w or 0)
            if (int(cc), int(ss)) in select_pairs:
                select_weekly += w
            else:
                single_weekly += w

        total_weekly = single_weekly + select_weekly
        gap = ts_cnt - total_weekly

        rows.append({
            "class_id": cid,
            "class_name": cname,
            "timeslot_cnt": ts_cnt,
            "single_weekly": single_weekly,
            "select_weekly": select_weekly,
            "total_weekly": total_weekly,
            "gap": gap,  # 0 が理想（= 31一致）
        })

    # 見やすさ：gapがズレてるクラスを上に
    rows.sort(key=lambda r: (r["gap"] != 0, abs(r["gap"])), reverse=True)
    return ts_cnt, rows




    # ===== ここから追加（作成前チェック用のクラス別集計） =====

    # same_time の全グループが1つのリストであるならそれを使う
    # もし class_joint / select_group / teacher_tt に分かれているなら結合して渡す
    _same_time_all = []
    try:
        # 分割されている想定（存在しなければ except で無視される）
        _same_time_all += (same_time_class_joint_groups or [])
        _same_time_all += (same_time_select_groups or [])
        _same_time_all += (same_time_teacher_tt_groups or [])
    except Exception:
        pass

    # 1本の same_time_groups しか無い実装ならこちらが効く
    if not _same_time_all:
        try:
            _same_time_all = same_time_groups or []
        except Exception:
            _same_time_all = []

    timeslot_cnt, class_load_rows = build_class_load_summary(
        classes=classes,
        timeslots=timeslots,
        cs_weekly_map=cs_weekly_map,
        same_time_groups=_same_time_all,
    )

    # 旧診断は画面に出さない（必要なら True に戻せるようフラグだけ残す）
    show_diagnostics = False

    # ===== ここまで追加 =====



def build_class_load_rows_from_db(cursor, school_id, timeslots):
    """
    作成前チェック（クラス別）:
      - timeslot_cnt : 週の時限数（timeslots件数）
      - single_weekly: 選択枠を除いた weekly_classes 合計
      - select_weekly: 同一クラス内で「同時刻に複数科目」がぶら下がる same_time グループを選択枠とみなし、
                      そのグループの必要コマを「メンバーの weekly_classes の最大」で1回だけ数える
      - total_weekly : single + select
      - gap          : timeslot_cnt - total_weekly
    """
    from collections import defaultdict

    ts_cnt = len(timeslots or [])



    from flask import current_app
    current_app.logger.info(
        "[PRECHECK] build_class_load_rows_from_db called: school_id=%s ts_cnt=%s",
        str(school_id), str(ts_cnt)
    )




    # 1) classes（class_id, class_name）:contentReference[oaicite:3]{index=3}
    cursor.execute(
        "SELECT class_id, class_name FROM classes WHERE school_id=%s ORDER BY class_id",
        (school_id,),
    )
    classes = cursor.fetchall() or []

    # 2) class_subjects（weekly_classes）:contentReference[oaicite:4]{index=4}
    cursor.execute(
        "SELECT class_id, subject_id, weekly_classes FROM class_subjects WHERE school_id=%s",
        (school_id,),
    )
    cs_rows = cursor.fetchall() or []

    # 2) class_subjects（単コマ: (class,subject) は重複行があり得るので「足し算」しない）
    #    例：同一科目が複数行で入っていると、単純加算で必要コマが過大になるため。
    weekly = defaultdict(int)
    for r in cs_rows:
        try:
            cid = int(r["class_id"])
            sid_ = int(r["subject_id"])
            w = int(r.get("weekly_classes") or 0)
        except Exception:
            continue

        if w <= 0:
            continue

        key = (cid, sid_)
        # 代表値は MAX（同一ペアの重複を吸収）
        if w > weekly[key]:
            weekly[key] = w



    # 3) same_time のグループ（teacher_tt は除外）
    # 3) selected_subjects の group_name を「同時展開（選択枠）」として集計する
    #    ※候補が1つのクラスでも、その枠に参加していれば1枠として数える
    cursor.execute(
        """
        SELECT class_id, subject_id, group_name
        FROM selected_subjects
        WHERE school_id = %s
          AND group_name IS NOT NULL
          AND TRIM(REPLACE(group_name, '　', '')) <> ''
        """,
        (school_id,),
    )
    ss_rows = cursor.fetchall() or []

    groups = defaultdict(list)  # group_name -> [(class_id, subject_id), ...]
    for r in ss_rows:
        try:
            cid = int(r["class_id"])
            sid_ = int(r["subject_id"])
            gnm = (r.get("group_name") or "").strip()
        except Exception:
            continue
        if not gnm:
            continue
        groups[gnm].append((cid, sid_))

    # 4) group_name ごとに、クラス別の候補科目集合を作る → 枠の必要コマは MAX(weekly) で1回だけ数える
    select_pairs = set()                 # (class_id, subject_id) … group_name 参加科目（単コマから除外するため）
    select_group_req = defaultdict(int)  # (class_id, group_name) -> req（その枠の必要コマ数）

    for gname, pairs in groups.items():
        per_class = defaultdict(set)  # class_id -> {subject_id,...}
        for cid, sid_ in pairs:
            per_class[cid].add(sid_)

        for cid, subj_set in per_class.items():
            # ★ここが本修正：候補が1つでも枠として数える（len>=2 ではない）
            req = 0
            for sid_ in subj_set:
                select_pairs.add((cid, sid_))
                req = max(req, int(weekly.get((cid, sid_), 0) or 0))
            # req が 0 でも枠の存在は残す（診断で見える化するため）
            select_group_req[(cid, gname)] = int(req or 0)

    # 5) ここまでで、
    #    - select_pairs: group_name 参加科目（単コマから除外）
    #    - select_group_req: class×group_name の枠コマ数（候補1でも計上）


    from flask import current_app

    for target in (60, 61):
        g_cnt = sum(1 for (cc, _g), _req in select_group_req.items() if int(cc) == target)
        s_sum = sum(int(_req or 0) for (cc, _g), _req in select_group_req.items() if int(cc) == target)
        w_sum = sum(int(w or 0) for (cc, _sid), w in weekly.items() if int(cc) == target)

        current_app.logger.info(
            "[PRECHECK] class_id=%s weekly_sum=%s group_cnt=%s select_sum=%s",
            str(target), str(w_sum), str(g_cnt), str(s_sum)
        )



    # =========================================================
    # weekly を (class_id, subject_id) に正規化（教師次元があっても二重計上しない）
    #  - 同一 (class, subject) が複数行ある場合は MAX を代表にする
    # =========================================================
    weekly_cs = {}  # (class_id, subject_id) -> weekly_hours

    for k, v in (weekly or {}).items():
        if not isinstance(k, tuple):
            continue
        if len(k) >= 2:
            c_id = int(k[0])
            s_id = int(k[1])
        else:
            continue

        hrs = int(v or 0)
        key = (c_id, s_id)
        if hrs > int(weekly_cs.get(key, 0) or 0):
            weekly_cs[key] = hrs




    # 6) クラス別集計
    rows = []

    # weekly_cs が作れていない場合でも落ちないように保険（基本は weekly_cs を使う）
    try:
        _weekly_src = weekly_cs
    except NameError:
        _weekly_src = weekly

    for c in classes:
        cid = int(c["class_id"])
        cname = c.get("class_name") or str(cid)

        single = 0
        for (cc, sid_), w in (_weekly_src or {}).items():
            cc = int(cc)
            sid_ = int(sid_)
            if cc == cid and (cc, sid_) not in select_pairs:
                single += int(w or 0)

        select = 0
        for (cc, gid), req in (select_group_req or {}).items():
            if int(cc) == cid:
                select += int(req or 0)

        total = int(single) + int(select)
        gap = int(ts_cnt) - int(total)

        rows.append(
            {
                "class_id": cid,
                "class_name": cname,
                "timeslot_cnt": int(ts_cnt),
                "single_weekly": int(single),
                "select_weekly": int(select),
                "total_weekly": int(total),
                "gap": int(gap),
            }
        )

    rows.sort(key=lambda r: r["class_id"])
    return rows, ts_cnt






# ============================================================
# 時間割作成＆表示（修正版：same_time をスリム化＆確実にハード化）
# ============================================================

@schedules_bp.route("/update_schedules",  methods=["GET", "POST"], endpoint="update_schedules", strict_slashes=False)
@schedules_bp.route("/update_schedules/", methods=["GET", "POST"], strict_slashes=False)
#★★★設計方針5.1: メイン処理（DB取得→allowed_ts_map→制約適用→診断→solver→保存）
def update_schedules():
    try:
        current_app.logger.info("update_schedules: %s %s", request.method, request.path)
    except Exception:
        pass

    sid = _sid()


    # ★必ず先に用意（途中分岐で soft_report を append しても落ちないようにする）
    soft_report = []
    try:
        sr = session.get("soft_report")
        if isinstance(sr, list):
            soft_report = list(sr)
    except Exception:
        pass



    # 事前診断用
    cs_priority_list = []

    if sid is None:
        flash("school_id が未設定です。ログインし直してください。", "error")
        return redirect(url_for("auth.login"))


    # masters/constraints 正規化（※ここは既存のまま）
    maps = get_master_maps(sid)
    cons_dict  = get_constraints_normalized(sid)
    cons_split = split_constraints(cons_dict)
    # GET 側にも使うキー（既存互換）
    consecutive_constraints = cons_split.get("consecutive", [])
    specific_constraints    = cons_split.get("specific", [])






    # ---------------------------------
    # POST：作成
    # ---------------------------------
    if request.method == "POST":

        # ============================================================
        # ★INFEASIBLE 切り分けスイッチ（ここだけ編集して原因を特定）
        # ============================================================
        DEBUG_DISABLE = set()

        # 診断中は保存しない（FEASIBLE を見つけたら True→False に戻す）
        DEBUG_ISOLATE_ONLY = False

        # ★2-B/2-C/2-E: スイッチから各フラグを派生
        DEBUG_ENFORCE_CONSECUTIVE = True
        IGNORE_CLASS_ONE_PER_SLOT = False
        DEBUG_IGNORE_UNAVAILABLE  = False
        VERBOSE_FLASH = False
        conn = None
        cursor = None

        # ★★★③用：PRECHECK結果を「POST全体」で保持（INFEASIBLE画面に流用）
        pre_ts_cnt = None
        pre_class_load_rows = []
        pre_mismatch_rows = []

        conn = get_db_connection()
        cursor = get_dict_cursor(conn, buffered=True)

        # === [STEP2] 入力テーブル監視（原因切り分け用）========================
        def _count_one(sql, params):
            cursor.execute(sql, params)
            r = cursor.fetchone()
            if isinstance(r, dict):
                return int(next(iter(r.values())))
            return int(r[0])

        input_counts_before = {
            "class_subjects": _count_one("SELECT COUNT(*) AS n FROM class_subjects WHERE school_id=%s", (sid,)),
            "class_subject_teachers": _count_one("SELECT COUNT(*) AS n FROM class_subject_teachers WHERE school_id=%s", (sid,)),
            "selected_subjects": _count_one("SELECT COUNT(*) AS n FROM selected_subjects WHERE school_id=%s", (sid,)),
        }
        try:
            current_app.logger.info("[INPUT-COUNT][BEFORE] %s", input_counts_before)
        except Exception:
            pass
        # === [STEP2] END =====================================================

        try:
            # --- 必要データの取得 ---
            cursor.execute("SELECT * FROM classes WHERE school_id=%s", (sid,))
            classes = cursor.fetchall() or []

            cursor.execute("SELECT * FROM teachers WHERE school_id=%s", (sid,))
            teachers = cursor.fetchall() or []

            cursor.execute("SELECT * FROM subjects WHERE school_id=%s", (sid,))
            subjects = cursor.fetchall() or []

            cursor.execute(
                "SELECT timeslot_id, day_of_week, number, title FROM timeslots WHERE school_id=%s",
                (sid,),
            )
            timeslots = cursor.fetchall() or []

            cursor.execute("SELECT * FROM class_subjects WHERE school_id=%s", (sid,))
            class_subjects = cursor.fetchall() or []

            # --- unavailable（教師×時限） ---
            cursor.execute(
                """
                SELECT
                    cm.teacher_id AS teacher_id,
                    c.timeslot_id AS timeslot_id
                FROM constraints AS c
                JOIN constraint_members AS cm
                  ON cm.constraint_id = c.id
                WHERE c.school_id = %s 
                  AND c.is_enabled = 1 
                  AND c.type = 'unavailable'
                  AND cm.teacher_id IS NOT NULL
                  AND c.timeslot_id IS NOT NULL
                """,
                (sid,),
            )
            teacher_unavailables = cursor.fetchall() or []


            # --- specific / fixed（固定） ---
            cursor.execute(
                """
                SELECT
                    c.id          AS constraint_id,
                    c.type        AS ctype,
                    c.timeslot_id AS timeslot_id,
                    cm.class_id   AS class_id,
                    cm.subject_id AS subject_id,
                    cm.teacher_id AS teacher_id
                FROM constraints AS c
                JOIN constraint_members AS cm
                  ON cm.constraint_id = c.id
                WHERE c.school_id = %s 
                  AND c.is_enabled = 1 
                  AND c.type IN ('specific', 'fixed')
                  AND c.timeslot_id IS NOT NULL
                  AND (cm.class_id IS NOT NULL OR cm.subject_id IS NOT NULL OR cm.teacher_id IS NOT NULL)
                """,
                (sid,),
            )
            specific_rows = cursor.fetchall() or []



            specific_assignments = set()
            for r in (specific_rows or []):
                c_id = r.get("class_id")
                s_id = r.get("subject_id")
                ts = r.get("timeslot_id")
                if c_id and s_id and ts:
                    specific_assignments.add((int(c_id), int(s_id), int(ts)))

            # --- 教師スケジュール変数 ---
            schedule = {}
            cs_weekly_map = {}
            cs_teachers_map = defaultdict(list)

            # === CP-SAT モデル構築 ===
            model = cp_model.CpModel()

            # class_subjects から weekly と teacher を構築
            for cs in (class_subjects or []):
                c_id = cs.get("class_id")
                s_id = cs.get("subject_id")
                if c_id is None or s_id is None:
                    continue
                c_id = int(c_id)
                s_id = int(s_id)

                w = cs.get("weekly_classes", 1)
                try:
                    w = int(w)
                except Exception:
                    w = 1

                key = (c_id, s_id)
                if key not in cs_weekly_map:
                    cs_weekly_map[key] = w
                else:
                    cs_weekly_map[key] = max(int(cs_weekly_map[key]), w)

                teacher_id = cs.get("teacher_id")
                if teacher_id:
                    t_id = int(teacher_id)
                    if t_id not in cs_teachers_map[key]:
                        cs_teachers_map[key].append(t_id)
                else:
                    cursor.execute(
                        """
                        SELECT teacher_id
                          FROM class_subject_teachers
                         WHERE school_id=%s AND class_subject_id=%s
                        """,
                        (sid, cs.get("class_subject_id")),
                    )
                    teachers_for_subject = cursor.fetchall() or []
                    for teacher in teachers_for_subject:
                        t_id = teacher.get("teacher_id") if isinstance(teacher, dict) else teacher[0]
                        if t_id:
                            t_id = int(t_id)
                            if t_id not in cs_teachers_map[key]:
                                cs_teachers_map[key].append(t_id)

            if not cs_teachers_map:
                flash(
                    "担当教師情報が見つかりません。class_subjects / class_subject_teachers を確認してください。",
                    "danger",
                )
                if conn:
                    conn.rollback()
                return redirect(url_for("schedules.update_schedules", school_id=sid))

            # schedule[(c,s,t,ts)]
            for (c_id, s_id), t_list in (cs_teachers_map or {}).items():
                for t_id in (t_list or []):
                    for ts in (timeslots or []):
                        ts_id = int(ts["timeslot_id"])
                        schedule[(c_id, s_id, t_id, ts_id)] = model.NewBoolVar(
                            f"class_{c_id}_sub_{s_id}_t_{t_id}_ts_{ts_id}"
                        )

            # subject_in_slot[(c,s,ts)]
            subject_in_slot = {}
            for (c_id, s_id) in (cs_weekly_map or {}).keys():
                for ts in (timeslots or []):
                    ts_id = int(ts["timeslot_id"])
                    subject_in_slot[(c_id, s_id, ts_id)] = model.NewBoolVar(
                        f"subject_in_slot_c{c_id}_s{s_id}_ts{ts_id}"
                    )

            # (C') 週コマ数ぴったり
            for (c_id, s_id), w in (cs_weekly_map or {}).items():
                model.Add(
                    sum(subject_in_slot[(c_id, s_id, int(ts["timeslot_id"]))] for ts in (timeslots or [])) == int(w)
                )

            # ============================================================
            # ★same_time を 1回だけ取得（以降この same_time_groups を全ての処理で共有）
            # ============================================================
            same_time_groups = fetch_same_time_groups(cursor, sid) or []

            # subtype カウントログ
            def _norm_st(x):
                x = (x or "").strip()
                return x if x else "(blank)"

            _counts = {}
            for g in (same_time_groups or []):
                st = _norm_st(g.get("subtype"))
                _counts[st] = _counts.get(st, 0) + 1
            try:
                current_app.logger.info("[SAME-TIME-COUNT] %s", _counts)
            except Exception:
                pass

            # subtype フィルタ（切り分け用）
            DEBUG_FILTER_SAME_TIME_BY_SUBTYPE = False
            DEBUG_ALLOWED_SAME_TIME_SUBTYPES = ["class_joint", "teacher_tt", "select_group"]

            if DEBUG_FILTER_SAME_TIME_BY_SUBTYPE:
                _before = len(same_time_groups or [])
                _allow = set(_norm_st(x) for x in (DEBUG_ALLOWED_SAME_TIME_SUBTYPES or []))
                same_time_groups = [
                    g for g in (same_time_groups or [])
                    if _norm_st(g.get("subtype")) in _allow
                ]
                _after = len(same_time_groups or [])
                try:
                    current_app.logger.info("[SAME-TIME-MODE] allow=%s %d -> %d", sorted(list(_allow)), _before, _after)
                except Exception:
                    pass

            # ============================================================


            # === PRECHECK用：selected_subjects（group_name付き）を取得して保持 ===
            _pre_ss_rows = []
            try:
                cursor.execute(
                    """

                    SELECT
                        class_id,
                        subject_id,
                        TRIM(group_name) AS group_name,
                        COALESCE(shared_group, 0) AS shared_group
                      FROM selected_subjects
                     WHERE school_id=%s
                       AND group_name IS NOT NULL
                       AND TRIM(group_name) <> ''
                    """,
                    (sid,),
                )
                _pre_ss_rows = cursor.fetchall() or []
                current_app.logger.info("[PRECHECK][SS] rows=%d", len(_pre_ss_rows))
            except Exception as e:
                current_app.logger.exception("[PRECHECK][SS] fetch failed: %s", e)
                _pre_ss_rows = []
            # ★①/②/③の核：PRECHECK（solverと同じ数え方）を先に作り、保持する
            #   - INFEASIBLE の画面でも「同じ集計」を必ず表示するため
            # ============================================================
            try:
                class_name_by_id = {
                    int(x["class_id"]): (x.get("class_name") or "")
                    for x in (classes or [])
                    if x.get("class_id") is not None
                }
                subject_name_by_id = {
                    int(x["subject_id"]): (x.get("display_name") or x.get("subject_name") or "")
                    for x in (subjects or [])
                    if x.get("subject_id") is not None
                }

                pre_ts_cnt, pre_class_load_rows, pre_mismatch_rows = build_class_load_summary_solver_aligned(
                    classes=classes,
                    timeslots=timeslots,
                    cs_weekly_map=cs_weekly_map,
                    same_time_groups=same_time_groups,
                    class_name_by_id=class_name_by_id,
                    subject_name_by_id=subject_name_by_id,
                    selected_subject_rows=_pre_ss_rows,
                )

                # CAP（確定矛盾）ログ
                bad_caps = [r for r in (pre_class_load_rows or []) if int(r.get("gap", 0)) < 0]
                if bad_caps:
                    current_app.logger.warning("[PRECHECK][CAP] over_cap=%d sample=%s", len(bad_caps), bad_caps[:5])

                if pre_mismatch_rows:
                    current_app.logger.warning(
                        "[PRECHECK][SAME-TIME-W-MISMATCH] count=%d sample=%s",
                        len(pre_mismatch_rows),
                        pre_mismatch_rows[:3],
                    )


                # ★確定矛盾（CAP=必要コマ数超過）のみ solver 前に停止する
                #   weekly混在は総合学科では起こり得るため「警告」に落として solver は回す
                if bad_caps:
                    msg_lines = []
                    if bad_caps:
                        msg_lines.append(
                            f"【確定矛盾】必要コマ数が時限数を超過しているクラスがあります: {len(bad_caps)}件（ログ: [PRECHECK][CAP]）"
                        )
                    if pre_mismatch_rows:
                        msg_lines.append(
                            f"【確定矛盾】same_time 内で週回数が混在しているグループがあります: {len(pre_mismatch_rows)}件（ログ: [PRECHECK][SAME-TIME-W-MISMATCH]）"
                        )
                        for x in (pre_mismatch_rows or [])[:5]:
                            subtype = (x.get("subtype") or "").strip()
                            gid = x.get("gid")
                            c_id = int(x.get("class_id") or 0)
                            cname = (x.get("class_name") or class_name_by_id.get(c_id) or str(c_id))
                            gname = (x.get("group_name") or "")

                            members_disp = []
                            try:
                                # SS_SELECT_GROUP は selected_subjects の group_name を正として復元
                                if subtype == "SS_SELECT_GROUP" and gname:
                                    for r in (_pre_ss_rows or []):
                                        try:
                                            cc = int(r.get("class_id"))
                                            ssid = int(r.get("subject_id"))
                                            gg = ("" if r.get("group_name") is None else str(r.get("group_name"))).replace("　", " ").strip()
                                            sg_raw = r.get("shared_group")
                                            try:
                                                sg = int(sg_raw or 0)
                                            except Exception:
                                                sg = 0
                                            gkey = f"{gg}__SG{sg}" if sg > 0 else gg
                                            if cc == c_id and gkey == gname:
                                                sname = subject_name_by_id.get(int(ssid), str(ssid))
                                                w = int(cs_weekly_map.get((c_id, int(ssid)), 0) or 0)
                                                members_disp.append(f"{sname}({w})")
                                        except Exception:
                                            continue
                                else:
                                    # constraints 由来（gid/subtype で同時グループを特定）
                                    for gg in (same_time_groups or []):
                                        if int(gg.get("gid") or 0) != int(gid or 0):
                                            continue
                                        if (gg.get("subtype") or "").strip() != subtype:
                                            continue
                                        for (cc, ssid) in (gg.get("pairs") or []):
                                            if int(cc) != c_id:
                                                continue
                                            sname = subject_name_by_id.get(int(ssid), str(ssid))
                                            w = int(cs_weekly_map.get((c_id, int(ssid)), 0) or 0)
                                            members_disp.append(f"{sname}({w})")
                                        break
                            except Exception:
                                members_disp = []

                            members_disp = sorted(set(members_disp))
                            weekly_vals = x.get("weekly_values")
                            extra = f"group={gname} " if gname else ""
                            msg_lines.append(
                                f" - class={cname} subtype={subtype} gid={gid} {extra}weekly={weekly_vals} members={', '.join(members_disp[:12])}"
                            )

                    flash("作成前チェックで矛盾を検出しました。まず同時制約/週回数の整合を直してください。", "danger")

                    base = build_view_context(sid)
                    base["teachers"] = teachers
                    base["timeslots"] = timeslots
                    base["teacher_unavail_map"] = {}
                    base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                    base["class_load_rows"] = pre_class_load_rows or []
                    base["show_diagnostics"] = False
                    base["soft_report"] = msg_lines

                    if conn:
                        conn.rollback()
                    return render_template("update_schedules.html", **base)




            except Exception as e:
                current_app.logger.exception("[PRECHECK] failed: %s", e)
                # PRECHECKが失敗しても solver は回す（pre_* は None/空のまま）

            # ============================================================
            # ★same_time ハード化
            # ============================================================
            if "same_time" not in DEBUG_DISABLE:
                add_same_time_hard(
                    model=model,
                    subject_in_slot=subject_in_slot,
                    cs_weekly_map=cs_weekly_map,
                    timeslots=timeslots,
                    same_time_groups=same_time_groups,
                    logger=current_app.logger,
                )

            # class_joint（教師重複カウント調整用）
            same_time_class_joint_groups = build_class_joint_groups_by_subject(same_time_groups, cs_weekly_map)



            # -------------------------------------------------------------
            # (A) 1クラス同時刻 1 科目（同時ブロックは代表1コマ扱い）
            #   - 選択枠(select_group)は selected_subjects(group_name) を最優先
            #   - selected_subjects が無い/空の時だけ same_time_groups の select_group をfallback
            # -------------------------------------------------------------
            parallel_members = set()
            parallel_reps_by_class = defaultdict(list)
            parallel_tags_by_class = defaultdict(set)
            parallel_tag_by_cs = {}
            parallel_group_members_by_tag = {}
            parallel_multi_tag_cs = []   # 同一csが複数タグ所属
            parallel_by_subtype = {}
            suspicious_non_select = []

            # ===== A-1) selected_subjects を使って「選択枠タグ」を作る =====
            ss_used = False
            ss_groups_by_class = defaultdict(lambda: defaultdict(set))  # class_id -> gkey -> {subject_id}

            for r in (_pre_ss_rows or []):
                try:
                    c_id = int((r.get("class_id") if isinstance(r, dict) else r[0]))
                    s_id = int((r.get("subject_id") if isinstance(r, dict) else r[1]))
                    g = (r.get("group_name") if isinstance(r, dict) else (r[2] if len(r) >= 3 else None))
                    sg_raw = (r.get("shared_group") if isinstance(r, dict) else (r[3] if len(r) >= 4 else None))
                except Exception:
                    continue

                g = ("" if g is None else str(g)).replace("　", " ").strip()
                if not g:
                    continue

                try:
                    sg = int(sg_raw or 0)
                except Exception:
                    sg = 0

                # group_name を主キーに。shared_group があれば衝突防止に付け足すだけ。
                gkey = f"{g}__SG{sg}" if sg > 0 else g
                ss_groups_by_class[c_id][gkey].add(s_id)

            for c_id, gmap in (ss_groups_by_class or {}).items():
                for gkey, subj_set in (gmap or {}).items():
                    if len(subj_set) < 2:
                        continue

                    members = []
                    for s_id in sorted(subj_set):
                        cs_key = (int(c_id), int(s_id))
                        if cs_key in (cs_weekly_map or {}):
                            members.append(cs_key)

                    if not members:
                        continue

                    ss_used = True
                    subtype = "select_group"
                    tag = f"{subtype}:{gkey}:c{int(c_id)}"

                    parallel_tags_by_class[int(c_id)].add(tag)

                    prev_members = parallel_group_members_by_tag.get(tag) or []
                    merged_members = sorted(set(prev_members) | set(members))

                    for cs_key in merged_members:
                        parallel_members.add(cs_key)
                        prev = parallel_tag_by_cs.get(cs_key)
                        if prev and prev != tag:
                            parallel_multi_tag_cs.append((cs_key, prev, tag))
                            try:
                                current_app.logger.warning(
                                    "[PARALLEL][WARN] cs belongs to multiple tags: cs=%s prev=%s new=%s",
                                    cs_key, prev, tag
                                )
                            except Exception:
                                pass
                        parallel_tag_by_cs[cs_key] = tag

                    parallel_group_members_by_tag[tag] = merged_members

                    rep = merged_members[0]
                    if rep not in parallel_reps_by_class[int(c_id)]:
                        parallel_reps_by_class[int(c_id)].append(rep)

                    parallel_by_subtype[subtype] = parallel_by_subtype.get(subtype, 0) + 1

            # ===== A-2) fallback: same_time_groups から推定（selected_subjects が無い場合のみ） =====
            if not ss_used:
                for g in (same_time_groups or []):
                    subtype = (g.get("subtype") or "").strip() or "(blank)"
                    gid = g.get("gid")
                    if subtype != "select_group":
                        continue

                    tag_base = f"{subtype}:{gid}"

                    by_class = defaultdict(list)
                    for (c_id, s_id) in (g.get("pairs") or []):
                        try:
                            c_id = int(c_id)
                            s_id = int(s_id)
                        except Exception:
                            continue
                        if (c_id, s_id) not in (cs_weekly_map or {}):
                            continue
                        by_class[c_id].append((c_id, s_id))

                    for c_id, members in by_class.items():
                        if len(members) < 2:
                            continue

                        tag = f"{tag_base}:c{c_id}"
                        parallel_tags_by_class[c_id].add(tag)

                        prev_members = parallel_group_members_by_tag.get(tag) or []
                        merged_members = sorted(set(prev_members) | set(members))

                        for cs_key in merged_members:
                            parallel_members.add(cs_key)
                            prev = parallel_tag_by_cs.get(cs_key)
                            if prev and prev != tag:
                                parallel_multi_tag_cs.append((cs_key, prev, tag))
                                try:
                                    current_app.logger.warning(
                                        "[PARALLEL][WARN] cs belongs to multiple tags: cs=%s prev=%s new=%s",
                                        cs_key, prev, tag
                                    )
                                except Exception:
                                    pass
                            parallel_tag_by_cs[cs_key] = tag

                        parallel_group_members_by_tag[tag] = merged_members

                        rep = merged_members[0]
                        if rep not in parallel_reps_by_class[c_id]:
                            parallel_reps_by_class[c_id].append(rep)

                        parallel_by_subtype[subtype] = parallel_by_subtype.get(subtype, 0) + 1

            try:
                current_app.logger.info(
                    "[ONE-PER-SLOT] parallel members=%d reps=%d by_subtype=%s",
                    len(parallel_members),
                    sum(len(v) for v in parallel_reps_by_class.values()),
                    parallel_by_subtype,
                )
            except Exception:
                pass

            # -------------------------------------------------------------
            # ★PRECHECK: [ONE-PER-SLOT-DEMAND]
            #   1クラス1時限（選択枠は代表1コマ）で必要コマが時限数を超えるなら確定矛盾
            # -------------------------------------------------------------
            if not IGNORE_CLASS_ONE_PER_SLOT:
                try:
                    ts_cnt = len(timeslots or [])
                    class_name_by_id_d = {int(x["class_id"]): (x.get("class_name") or "") for x in (classes or []) if x.get("class_id") is not None}
                    subject_name_by_id_d = {int(x["subject_id"]): (x.get("display_name") or x.get("subject_name") or "") for x in (subjects or []) if x.get("subject_id") is not None}

                    bad_demand = []
                    for c in (classes or []):
                        c_id = int(c.get("class_id"))
                        # 通常（選択枠構成員を除く）
                        normal = 0
                        for (cid, sid_), w in (cs_weekly_map or {}).items():
                            if cid != c_id:
                                continue
                            if (cid, sid_) in parallel_members:
                                continue
                            normal += int(w or 0)

                        # 選択枠（タグごとに wmax を1回だけ）
                        tag_sum = 0
                        tags = sorted(set(parallel_tags_by_class.get(c_id, []) or []))
                        tag_samples = []
                        for tag in tags[:8]:
                            mem = parallel_group_members_by_tag.get(tag) or []
                            wset = sorted({int(cs_weekly_map.get(cs_key, 0) or 0) for cs_key in mem})
                            wmax = max(wset) if wset else 0
                            tag_sum += int(wmax)

                            # 表示用に member を少しだけ
                            mem_disp = []
                            for (cc, ssid) in mem[:10]:
                                sname = subject_name_by_id_d.get(int(ssid)) or str(ssid)
                                ww = int(cs_weekly_map.get((int(cc), int(ssid)), 0) or 0)
                                mem_disp.append(f"{sname}({ww})")
                            tag_samples.append({"tag": tag, "member_cnt": len(mem), "wset": wset, "wmax": wmax, "members": mem_disp})

                        demand = normal + tag_sum
                        slack = ts_cnt - demand
                        if slack < 0:
                            bad_demand.append({
                                "class_id": c_id,
                                "class": class_name_by_id_d.get(c_id) or str(c_id),
                                "ts_cnt": ts_cnt,
                                "normal": normal,
                                "tag": tag_sum,
                                "demand": demand,
                                "slack": slack,
                                "tags_sample": tag_samples,
                            })

                    bad_demand.sort(key=lambda r: r.get("slack", 0))

                    current_app.logger.warning(
                        "[PRECHECK][ONE-PER-SLOT-DEMAND] bad=%d sample=%s",
                        len(bad_demand),
                        bad_demand[:3],
                    )

                    if bad_demand:
                        x = bad_demand[0]
                        msg = [
                            "【確定矛盾】1クラス1時限(同時ブロック代表)の前提で、必要コマが時限数を超えています。",
                            f"- クラス={x.get('class')} (id={x.get('class_id')})",
                            f"- 時限数={x.get('ts_cnt')} / 通常={x.get('normal')} / 選択枠={x.get('tag')} / 合計={x.get('demand')} / 余裕={x.get('slack')}",
                            "▼選択枠（代表コマ扱い）サンプル",
                        ]
                        for t in (x.get("tags_sample") or [])[:5]:
                            msg.append(f" - tag={t.get('tag')} weekly候補={t.get('wset')} wmax={t.get('wmax')} members={', '.join(t.get('members') or [])}")

                        msg.extend([
                            "",
                            "（対処）以下のいずれかを見直してください。",
                            "  1) 選択枠(group_name)の付け間違い（本来別枠の科目が同じ枠になっている）",
                            "  2) class_subjects.weekly_classes の合計がそのクラスの週時限数を超えている",
                            "  3) 選択枠の中に「単独科目（毎週固定）」が混ざっている",
                        ])

                        flash("作成前チェックで矛盾を検出しました（必要コマ数が時限数超過）。", "danger")
                        if conn:
                            conn.rollback()

                        base = build_view_context(sid)
                        base["teachers"] = teachers
                        base["timeslots"] = timeslots
                        base["teacher_unavail_map"] = {}
                        base["show_diagnostics"] = False
                        base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                        base["class_load_rows"] = pre_class_load_rows or []
                        base["soft_report"] = msg
                        return render_template("update_schedules.html", **base)

                except Exception as e:
                    current_app.logger.exception("[PRECHECK][ONE-PER-SLOT-DEMAND] failed: %s", e)

            if not IGNORE_CLASS_ONE_PER_SLOT:
                # ★同じ時限に「選択タグ」をいくつまで同時に許すか
                #   まずは 2 で試す（必要なら 3 に上げる）
                MAX_SELECT_TAGS_PER_SLOT = 2

                for c in (classes or []):
                    c_id = int(c["class_id"])
                    tags = sorted(set(parallel_tags_by_class.get(c_id, []) or []))

                    for ts in (timeslots or []):
                        ts_id = int(ts["timeslot_id"])

                        # ----------------------------
                        # 通常（同時ブロックに属さない科目）は「同時に1つまで」
                        # ----------------------------
                        normal_vars = [
                            subject_in_slot[(cid, sid2, ts_id)]
                            for (cid, sid2) in (cs_weekly_map or {}).keys()
                            if cid == c_id and (cid, sid2) not in parallel_members
                        ]
                        if normal_vars:
                            model.Add(sum(normal_vars) <= 1)
                            normal_active = model.NewBoolVar(f"c{c_id}_ts{ts_id}_N")
                            model.Add(sum(normal_vars) >= normal_active)
                            for v in normal_vars:
                                model.Add(v <= normal_active)
                        else:
                            normal_active = model.NewBoolVar(f"c{c_id}_ts{ts_id}_N")
                            model.Add(normal_active == 0)

                        # ----------------------------
                        # 同時ブロック（選択タグ）の active を作る
                        #  - タグ内は複数科目同時OK（選択展開）
                        # ----------------------------
                        tag_actives = []
                        for idx, tag in enumerate(tags, start=1):
                            members = parallel_group_members_by_tag.get(tag) or []
                            mem_vars = []
                            for (mc, ms) in members:
                                v = subject_in_slot.get((mc, ms, ts_id))
                                if v is not None:
                                    mem_vars.append(v)

                            if not mem_vars:
                                continue

                            a = model.NewBoolVar(f"c{c_id}_ts{ts_id}_P{idx}")
                            model.Add(sum(mem_vars) >= a)
                            for v in mem_vars:
                                model.Add(v <= a)
                            tag_actives.append(a)

                        # ----------------------------
                        # 混在ルール
                        #  - 通常授業がある時は、選択タグは 0（※必要なら後でONにする）
                        #  - 選択タグ同士は MAX_SELECT_TAGS_PER_SLOT まで許可
                        # ----------------------------
                        if tag_actives:
                            # model.Add(sum(tag_actives) == 0).OnlyEnforceIf(normal_active)
                            model.Add(sum(tag_actives) <= MAX_SELECT_TAGS_PER_SLOT)

                        # ★空白禁止：この時限は必ず何か（通常 or 選択タグ）が入る
                        #  - tag_actives が空なら sum(tag_actives)=0 なので normal_active==1 を強制
                        model.Add(normal_active + sum(tag_actives) >= 1)



            # -------------------------------------------------------------
            # (B) 教師は同一時刻に最大 1 クラス（class_joint の重複カウント回避）
            # -------------------------------------------------------------
            teacher_conflict_skip = set()
            try:
                for group in (same_time_class_joint_groups or []):
                    by_teacher = defaultdict(list)
                    for (c_id, s_id) in group:
                        cs_key = (int(c_id), int(s_id))
                        t_list = cs_teachers_map.get(cs_key) or []
                        for t_id in t_list:
                            try:
                                by_teacher[int(t_id)].append(cs_key)
                            except Exception:
                                pass

                    for t_id, members in by_teacher.items():
                        if len(members) >= 2:
                            for cs_key in members[1:]:
                                teacher_conflict_skip.add(cs_key)

                current_app.logger.info(
                    "[CJ-TEACHER-SKIP] skip_cs=%d sample=%s",
                    len(teacher_conflict_skip),
                    list(sorted(teacher_conflict_skip))[:5],
                )
            except Exception:
                current_app.logger.exception("[CJ-TEACHER-SKIP] build failed")
                teacher_conflict_skip = set()

            if "teacher_conflict" not in DEBUG_DISABLE:
                for t in (teachers or []):
                    t_id = int(t["teacher_id"])
                    for ts in (timeslots or []):
                        ts_id = int(ts["timeslot_id"])
                        model.Add(
                            sum(
                                schedule[(c_id, s_id, t_id, ts_id)]
                                for (c_id, s_id), t_list in (cs_teachers_map or {}).items()
                                if (t_id in (t_list or []))
                                and ((c_id, s_id) not in teacher_conflict_skip)
                            ) <= 1
                        )

            # -------------------------------------------------------------
            # (C'') team_teach 判定（DB指定 + 自動判定）
            # -------------------------------------------------------------
            cursor.execute(
                """
                SELECT
                    cm.class_id   AS class_id,
                    cm.subject_id AS subject_id,
                    COUNT(DISTINCT cm.teacher_id) AS n_teachers
                FROM constraints AS c
                JOIN constraint_members AS cm
                  ON cm.constraint_id = c.id
                WHERE c.school_id = %s 
                  AND c.is_enabled = 1 
                  AND c.type = 'team_teach'
                  AND cm.class_id   IS NOT NULL
                  AND cm.subject_id IS NOT NULL
                  AND cm.teacher_id IS NOT NULL
                GROUP BY cm.class_id, cm.subject_id
                """,
                (sid,),
            )
            tt_rows = cursor.fetchall() or []


            team_teach_from_db = {(int(r["class_id"]), int(r["subject_id"])) for r in (tt_rows or [])}

            # ★設計方針どおり：TTは「制約で登録されたもの」を基本とする
            #   True にすると「複数教師が紐づく cs を自動的にTT扱い（全員同時）」にします
            AUTO_TEAM_TEACH = False
            auto_team_teach = (
                {k for k, t_list in (cs_teachers_map or {}).items() if len(set(t_list or [])) >= 2}
                if AUTO_TEAM_TEACH
                else set()
            )

            team_teach_pairs = team_teach_from_db | auto_team_teach



            # ============================================================
            # ★PRECHECK-2: 同時ブロックの矛盾を確定検出
            #   A) 同一 (class,subject) が複数同時ブロックに所属（=重なり）
            #   B) 同時ブロック内で同一教師が「必須担当」として2科目以上
            # ============================================================
            try:
                class_name_by_id2 = {int(x["class_id"]): (x.get("class_name") or "") for x in (classes or []) if x.get("class_id") is not None}
                subject_name_by_id2 = {int(x["subject_id"]): (x.get("display_name") or x.get("subject_name") or "") for x in (subjects or []) if x.get("subject_id") is not None}
                # ★追加：教員名/職番（表示用）
                teacher_name_by_id2 = {int(x["teacher_id"]): (x.get("teacher_name") or "") for x in (teachers or []) if x.get("teacher_id") is not None}
                teacher_number_by_id2 = {int(x["teacher_id"]): int(x.get("number") or 0) for x in (teachers or []) if x.get("teacher_id") is not None}
            except Exception:
                class_name_by_id2 = {}
                subject_name_by_id2 = {}
                teacher_name_by_id2 = {}
                teacher_number_by_id2 = {}

            # A) 多重所属があるなら確定矛盾（強制同期が絡むとすぐ詰む）
            if "parallel_multi_tag_cs" in locals() and parallel_multi_tag_cs:
                sample = parallel_multi_tag_cs[:10]
                msg = ["【確定矛盾】同一の(クラス,科目)が複数の同時ブロックに所属しています。"]
                for (cs_key, prev, new) in sample:
                    c_id, s_id = cs_key
                    msg.append(
                        f"- {class_name_by_id2.get(int(c_id), c_id)} / {subject_name_by_id2.get(int(s_id), s_id)} : {prev} -> {new}"
                    )
                msg.append("（対処）selected_subjects の group_name、または constraints の same_time 定義が重複しています。該当科目が1つの枠にだけ属するよう整理してください。")

                current_app.logger.warning("[PRECHECK][PARALLEL-MULTI-TAG] count=%d sample=%s", len(parallel_multi_tag_cs), sample)

                flash("作成前チェックで矛盾を検出しました（同時ブロックの重複所属）。ログを確認してください。", "danger")
                if conn:
                    conn.rollback()

                base = build_view_context(sid)
                base["teachers"] = teachers
                base["timeslots"] = timeslots
                base["teacher_unavail_map"] = {}
                base["show_diagnostics"] = False
                base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                base["class_load_rows"] = pre_class_load_rows or []
                base["soft_report"] = msg
                return render_template("update_schedules.html", **base)

            # B) 同時ブロック内「必須担当教師」の重複（単独担当 or TT）
            bad_parallel_teacher = []
            try:
                for tag, members in (parallel_group_members_by_tag or {}).items():
                    forced = defaultdict(list)  # teacher_id -> [cs_key,...]

                    for cs_key in (members or []):
                        t_list = sorted(set(cs_teachers_map.get(cs_key) or []))
                        if not t_list:
                            continue

                        if cs_key in (team_teach_pairs or set()):
                            # TT: 全員必須
                            for tid in t_list:
                                forced[int(tid)].append(cs_key)
                        elif len(t_list) == 1:
                            # 単独担当: その教師必須
                            forced[int(t_list[0])].append(cs_key)

                    conflicts = [(tid, lst) for tid, lst in forced.items() if len(lst) >= 2]
                    if conflicts:
                        # 先頭だけ保持（大量ログ抑制）
                        tid, lst = conflicts[0]
                        bad_parallel_teacher.append({"tag": tag, "teacher_id": tid, "members": lst})

                if bad_parallel_teacher:
                    x = bad_parallel_teacher[0]

                    tid = int(x.get("teacher_id") or 0)
                    tname = (teacher_name_by_id2.get(tid) or "").strip()
                    tnum = int(teacher_number_by_id2.get(tid, 0) or 0)
                    teacher_label = (f"{tname}（{tnum}）" if (tname and tnum) else (tname or f"teacher_id={tid}"))

                    # どの科目が衝突しているか、担当候補一覧・理由まで出す（最大10件）
                    details = []
                    for (c_id, s_id) in (x.get("members") or [])[:10]:
                        try:
                            c_id = int(c_id)
                            s_id = int(s_id)
                        except Exception:
                            continue

                        cname = class_name_by_id2.get(c_id) or str(c_id)
                        sname = subject_name_by_id2.get(s_id) or str(s_id)
                        w = int(cs_weekly_map.get((c_id, s_id), 0) or 0)

                        t_list = sorted(set(cs_teachers_map.get((c_id, s_id)) or []))
                        t_disp = []
                        for t in t_list:
                            try:
                                t = int(t)
                            except Exception:
                                continue
                            nm = (teacher_name_by_id2.get(t) or "").strip()
                            no = int(teacher_number_by_id2.get(t, 0) or 0)
                            t_disp.append(f"{nm}（{no}）" if (nm and no) else (nm or f"id={t}"))

                        if (c_id, s_id) in (team_teach_pairs or set()):
                            reason = "TT（全員必須）"
                        elif len(t_list) == 1:
                            reason = "単独担当（必須）"
                        else:
                            reason = f"候補{len(t_list)}名（本来は必須衝突になりにくい）"

                        details.append(f"- {cname}:{sname} weekly={w} / 担当={', '.join(t_disp) if t_disp else '未設定'} / {reason}")

                    msg = [
                        "【確定矛盾】同時ブロック内で同一教師が“必須担当”として複数科目に入っています。",
                        f"- tag={x.get('tag')}",
                        f"- teacher={teacher_label}（id={tid}）",
                        "▼衝突している科目（最大10件）",
                        *details,
                        "",
                        "（対処候補：どれか1つでOKなことが多い）",
                        "  1) フラット科目データで同じ group_name 内に同一教師の重複レコードがある → 片方削除/修正",
                        "  2) どちらかの科目に担当候補を追加（class_subject_teachers）して『単独担当』を解消",
                        "  3) 選択枠の group_name を分割（同じ教師が同じ枠に来ないようにする）",
                        "  4) TTのつもりがないのにTT扱いなら、TT設定（team-teach）側を見直す",
                    ]

                    current_app.logger.warning(
                        "[PRECHECK][PARALLEL-TEACHER] bad=%d sample=%s",
                        len(bad_parallel_teacher),
                        bad_parallel_teacher[:3],
                    )

                    flash("作成前チェックで矛盾を検出しました（同時ブロック内の教師必須担当が重複）。", "danger")
                    if conn:
                        conn.rollback()

                    base = build_view_context(sid)
                    base["teachers"] = teachers
                    base["timeslots"] = timeslots
                    base["teacher_unavail_map"] = {}
                    base["show_diagnostics"] = False
                    base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                    base["class_load_rows"] = pre_class_load_rows or []
                    base["soft_report"] = msg
                    return render_template("update_schedules.html", **base)

            except Exception as e:
                current_app.logger.exception("[PRECHECK][PARALLEL-TEACHER] failed: %s", e)



            # 科目↔教師リンク
            for (c_id, s_id), t_list in (cs_teachers_map or {}).items():
                t_list = sorted(set(t_list or []))
                if not t_list:
                    continue

                for ts in (timeslots or []):
                    ts_id = int(ts["timeslot_id"])

                    for t_id in t_list:
                        model.Add(schedule[(c_id, s_id, int(t_id), ts_id)] <= subject_in_slot[(c_id, s_id, ts_id)])

                    if (c_id, s_id) in team_teach_pairs and len(t_list) >= 2:
                        if "team_teach_strict" not in DEBUG_DISABLE:
                            model.Add(
                                sum(schedule[(c_id, s_id, int(t_id), ts_id)] for t_id in t_list)
                                == len(t_list) * subject_in_slot[(c_id, s_id, ts_id)]
                            )
                        else:
                            model.Add(
                                sum(schedule[(c_id, s_id, int(t_id), ts_id)] for t_id in t_list)
                                >= subject_in_slot[(c_id, s_id, ts_id)]
                            )
                            model.Add(
                                sum(schedule[(c_id, s_id, int(t_id), ts_id)] for t_id in t_list)
                                <= len(t_list) * subject_in_slot[(c_id, s_id, ts_id)]
                            )
                    else:
                        model.Add(
                            sum(schedule[(c_id, s_id, int(t_id), ts_id)] for t_id in t_list)
                            == subject_in_slot[(c_id, s_id, ts_id)]
                        )

            # -------------------------------------------------------------
            # (D) unavailable（教師×時限の禁止）
            # -------------------------------------------------------------
            teacher_unavail_pairs = set()
            teacher_id_set  = {int(t.get("teacher_id")) for t in (teachers or []) if t.get("teacher_id") is not None}
            timeslot_id_set = {int(ts.get("timeslot_id")) for ts in (timeslots or []) if ts.get("timeslot_id") is not None}

            for r in (teacher_unavailables or []):
                t_id = r.get("teacher_id")
                ts_id = r.get("timeslot_id")
                if t_id is None or ts_id is None:
                    continue
                try:
                    t_id = int(t_id)
                    ts_id = int(ts_id)
                except Exception:
                    continue
                if (t_id not in teacher_id_set) or (ts_id not in timeslot_id_set):
                    continue
                teacher_unavail_pairs.add((t_id, ts_id))

            # teachers.sidXX も反映（既存互換）
            for t in (teachers or []):
                tid = t.get("teacher_id")
                if tid is None:
                    continue
                try:
                    tid_int = int(tid)
                except Exception:
                    continue

                for ts_id in timeslot_id_set:
                    col2 = f"sid{int(ts_id):02d}"
                    col1 = f"sid{int(ts_id)}"
                    val = t.get(col2, t.get(col1, 0)) or 0
                    if int(val) == 1:
                        teacher_unavail_pairs.add((tid_int, int(ts_id)))

            if not DEBUG_IGNORE_UNAVAILABLE:
                for (t_id, ts_id) in (teacher_unavail_pairs or set()):
                    for (c_id, s_id), t_list in (cs_teachers_map or {}).items():
                        if t_id in (t_list or []):
                            model.Add(schedule[(c_id, s_id, int(t_id), int(ts_id))] == 0)

            # -------------------------------------------------------------
            # (E) specific（固定コマ）
            # -------------------------------------------------------------
            # -------------------------------------------------------------
            # (E) specific / fixed（固定コマ）
            # -------------------------------------------------------------
            _spec_triples = set()
            _spec_invalid_rows = []   # class/subject 欠け等
            if specific_rows:
                for r in (specific_rows or []):
                    c_id = r.get("class_id")
                    s_id = r.get("subject_id")
                    ts  = r.get("timeslot_id")
                    if c_id and s_id and ts:
                        _spec_triples.add((int(c_id), int(s_id), int(ts)))
                    else:
                        _spec_invalid_rows.append({
                            "constraint_id": r.get("constraint_id"),
                            "type": r.get("ctype"),
                            "class_id": c_id,
                            "subject_id": s_id,
                            "teacher_id": r.get("teacher_id"),
                            "timeslot_id": ts,
                        })

            ts_id_set = {int(t["timeslot_id"]) for t in (timeslots or []) if t.get("timeslot_id") is not None}

            if "specific" not in DEBUG_DISABLE:
                applied = 0
                skipped_unknown_cs = []
                skipped_unknown_ts = []
                skipped_no_teacher = []

                for (c_id, s_id, ts_id) in sorted(_spec_triples):
                    if ts_id not in ts_id_set:
                        skipped_unknown_ts.append((c_id, s_id, ts_id))
                        continue
                    if (c_id, s_id) not in cs_weekly_map:
                        skipped_unknown_cs.append((c_id, s_id, ts_id))
                        continue

                    model.Add(subject_in_slot[(c_id, s_id, int(ts_id))] == 1)

                    t_list = cs_teachers_map.get((c_id, s_id), []) or []
                    if not t_list:
                        skipped_no_teacher.append((c_id, s_id, ts_id))
                        # 科目は固定したが担当が0人なら teacher までは固定できない（後でPRECHECKで弾くのが理想）
                        continue

                    if (c_id, s_id) in team_teach_pairs:
                        for t_id in t_list:
                            model.Add(schedule[(c_id, s_id, int(t_id), int(ts_id))] == 1)
                    else:
                        model.Add(sum(schedule[(c_id, s_id, int(t_id), int(ts_id))] for t_id in t_list) == 1)

                    applied += 1

                try:
                    current_app.logger.info(
                        "[SPECIFIC] rows=%d triples=%d applied=%d invalid_rows=%d skip_cs=%d skip_ts=%d skip_no_teacher=%d "
                        "sample_invalid=%s sample_skip_cs=%s sample_skip_ts=%s",
                        len(specific_rows or []),
                        len(_spec_triples),
                        applied,
                        len(_spec_invalid_rows),
                        len(skipped_unknown_cs),
                        len(skipped_unknown_ts),
                        len(skipped_no_teacher),
                        _spec_invalid_rows[:3],
                        skipped_unknown_cs[:3],
                        skipped_unknown_ts[:3],
                    )
                except Exception:
                    pass

                # 画面にも「固定が効かなかった理由」を出す（成功しても気づけるように）
                if _spec_invalid_rows or skipped_unknown_cs or skipped_unknown_ts:
                    soft_report.append("【注意】固定（特定）制約の一部が適用されませんでした。ログ [SPECIFIC] を確認してください。")
                    if _spec_invalid_rows:
                        soft_report.append(f" - class/subject/timeslot 欠け: { _spec_invalid_rows[0] }")
                    if skipped_unknown_cs:
                        soft_report.append(f" - class_subjects 未登録でスキップ: { skipped_unknown_cs[0] }")
                    if skipped_unknown_ts:
                        soft_report.append(f" - timeslots に存在しない時限でスキップ: { skipped_unknown_ts[0] }")


            # ============================================================
            # ============================================================
            # 可用コマ/固定コマ
            # ============================================================
            teacher_unavail_ts = {}
            for (t_id, ts_id) in (teacher_unavail_pairs or set()):
                teacher_unavail_ts.setdefault(int(t_id), set()).add(int(ts_id))


            # ============================================================
            # ★PRECHECK-1: 教師キャパ（供給） vs 必要コマ（需要）チェック
            #   - TT(strict) と単独担当は「教師が必ず入る」ので forced 需要
            #   - 複数担当(非TT)は「誰か1人」なので、残キャパ合計で weekly を賄えるかだけ判定（必要条件）
            # ============================================================
            try:
                total_ts = len(timeslots or [])

                # 供給：教師が使える時限数（禁則を除外）
                supply = {}
                for t in (teachers or []):
                    if t.get("teacher_id") is None:
                        continue
                    tid = int(t["teacher_id"])
                    supply[tid] = total_ts - len(teacher_unavail_ts.get(tid, set()) or set())

                forced = defaultdict(int)   # teacher_id -> forced weekly sum
                forced_src = defaultdict(list)

                flex_pairs = []  # (c_id, s_id, weekly, teachers)
                for (c_id, s_id), weekly in (cs_weekly_map or {}).items():
                    try:
                        w = int(weekly)
                    except Exception:
                        w = 0
                    if w <= 0:
                        continue

                    cs_key = (int(c_id), int(s_id))

                    # 合同授業扱い（teacher_conflict 側で重複除外している cs は需要でも除外）
                    if cs_key in (teacher_conflict_skip or set()):
                        continue

                    t_list = sorted(set(cs_teachers_map.get(cs_key) or []))
                    if not t_list:
                        continue

                    if cs_key in (team_teach_pairs or set()):
                        # TT：全教師が毎回必要
                        for tid in t_list:
                            tid = int(tid)
                            forced[tid] += w
                            if len(forced_src[tid]) < 5:
                                forced_src[tid].append({"cs": cs_key, "weekly": w, "mode": "TT"})
                    elif len(t_list) == 1:
                        # 単独担当：その教師が毎回必要
                        tid = int(t_list[0])
                        forced[tid] += w
                        if len(forced_src[tid]) < 5:
                            forced_src[tid].append({"cs": cs_key, "weekly": w, "mode": "SINGLE"})
                    else:
                        # 複数担当(非TT)：誰か1人が入ればよい（必要条件として残キャパ合計で判定）
                        flex_pairs.append((cs_key[0], cs_key[1], w, [int(x) for x in t_list]))

                bad_forced = []
                remain = {}
                for tid, cap in (supply or {}).items():
                    d = int(forced.get(tid, 0))
                    r = int(cap) - d
                    remain[tid] = r
                    if r < 0:
                        bad_forced.append(
                            {"teacher_id": tid, "supply": int(cap), "forced": d, "remain": r, "src": forced_src.get(tid, [])}
                        )

                bad_flex = []
                for (c_id, s_id, w, t_list) in (flex_pairs or []):
                    cap_sum = sum(max(0, int(remain.get(int(tid), 0))) for tid in (t_list or []))
                    if cap_sum < int(w):
                        bad_flex.append(
                            {"class_id": int(c_id), "subject_id": int(s_id), "weekly": int(w), "cap_sum": int(cap_sum), "teachers": t_list}
                        )

                bad_forced.sort(key=lambda r: (r["remain"], r["supply"]))
                bad_flex.sort(key=lambda r: (r["cap_sum"] - r["weekly"], r["cap_sum"], -r["weekly"]))

                current_app.logger.warning("[PRECHECK][TEACHER-FORCED] bad=%d sample=%s", len(bad_forced), bad_forced[:3])
                current_app.logger.warning("[PRECHECK][TEACHER-FLEX] bad=%d sample=%s", len(bad_flex), bad_flex[:3])

                if bad_forced or bad_flex:
                    # 表示用マップ
                    try:
                        class_name_by_id = {int(x["class_id"]): (x.get("class_name") or "") for x in (classes or []) if x.get("class_id") is not None}
                    except Exception:
                        class_name_by_id = {}
                    try:
                        subject_name_by_id = {int(x["subject_id"]): (x.get("display_name") or x.get("subject_name") or "") for x in (subjects or []) if x.get("subject_id") is not None}
                    except Exception:
                        subject_name_by_id = {}
                    try:
                        teacher_name_by_id = {int(x["teacher_id"]): (x.get("teacher_name") or "") for x in (teachers or []) if x.get("teacher_id") is not None}
                        teacher_number_by_id = {int(x["teacher_id"]): int(x.get("number") or 0) for x in (teachers or []) if x.get("teacher_id") is not None}
                    except Exception:
                        teacher_name_by_id = {}
                        teacher_number_by_id = {}

                    msg = []
                    if bad_forced:
                        x = bad_forced[0]
                        t_id = int(x.get("teacher_id") or 0)
                        tname = (teacher_name_by_id.get(t_id) or "").strip()
                        tnum = int(teacher_number_by_id.get(t_id, 0) or 0)
                        teacher_label = (f"{tname}（{tnum}）" if (tname and tnum) else (tname or f"teacher_id={t_id}"))
                        msg.append(
                            f"【確定矛盾】教師キャパ不足: {teacher_label} supply={x.get('supply')} forced={x.get('forced')} remain={x.get('remain')}"
                        )
                        msg.append("（対処）TT扱いの見直し / 禁則緩和 / weekly削減 / 担当教師の分散")
                    if bad_flex:
                        x = bad_flex[0]
                        c_id = int(x.get("class_id") or 0)
                        s_id = int(x.get("subject_id") or 0)
                        cname = class_name_by_id.get(c_id) or str(c_id)
                        sname = subject_name_by_id.get(s_id) or str(s_id)
                        t_disp = []
                        for tid in (x.get("teachers") or []):
                            try:
                                tid = int(tid)
                            except Exception:
                                continue
                            nm = (teacher_name_by_id.get(tid) or "").strip()
                            no = int(teacher_number_by_id.get(tid, 0) or 0)
                            t_disp.append(f"{nm}（{no}）" if (nm and no) else (nm or f"id={tid}"))
                        msg.append(
                            f"【確定矛盾】担当候補の残キャパ合計が不足: {cname}:{sname} weekly={x.get('weekly')} cap_sum={x.get('cap_sum')} teachers={', '.join(t_disp) if t_disp else x.get('teachers')}"
                        )
                        msg.append("（対処）担当候補教師を増やす / 禁則緩和 / weekly削減")

                    flash("作成前チェックで教師キャパの確定矛盾を検出しました（ログも確認）。", "danger")

                    base = build_view_context(sid)
                    base["teachers"] = teachers
                    base["timeslots"] = timeslots
                    base["teacher_unavail_map"] = {}
                    base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                    base["class_load_rows"] = pre_class_load_rows or []
                    base["show_diagnostics"] = False
                    base["soft_report"] = msg + [
                        f"教師キャパ不足（forced>available）: {len(bad_forced)}件（ログ: [PRECHECK][TEACHER-FORCED]）",
                        f"担当候補の残キャパ不足: {len(bad_flex)}件（ログ: [PRECHECK][TEACHER-FLEX]）",
                    ]

                    if conn:
                        conn.rollback()
                    return render_template("update_schedules.html", **base)

            except Exception as e:
                current_app.logger.exception("[PRECHECK][TEACHER] failed: %s", e)




            spec_triples = _spec_triples
            allowed_ts_map, fixed_ts_map = build_feasible_timeslots(
                cs_weekly_map,
                cs_teachers_map,
                team_teach_pairs,
                teacher_unavail_ts,
                timeslots,
                specific_constraints=(cons_split.get("specific") or []),
                spec_triples=spec_triples,
            )

            # ★TRACE（ここが実行されているか/候補数の概要）
            try:
                current_app.logger.info(
                    "[TRACE] after build_feasible_timeslots: allowed_keys=%d fixed_keys=%d",
                    len(allowed_ts_map or {}),
                    len(fixed_ts_map or {}),
                )
            except Exception:
                pass



            # ============================================================
            # ★PRECHECK-0.5: 確定矛盾の検出（allowed不足 / 固定×禁則衝突）
            # ============================================================
            try:
                class_name_by_id = {
                    int(c.get("class_id")): (c.get("class_name") or "")
                    for c in (classes or [])
                    if c.get("class_id") is not None
                }
            except Exception:
                class_name_by_id = {}

            try:
                subject_name_by_id = {
                    int(s.get("subject_id")): (s.get("display_name") or s.get("subject_name") or "")
                    for s in (subjects or [])
                    if s.get("subject_id") is not None
                }
            except Exception:
                subject_name_by_id = {}

            # (1) allowed_ts_map が weekly を下回る cs を検出
            bad_cs_allowed = []
            for (c_id, s_id), weekly in (cs_weekly_map or {}).items():
                try:
                    w = int(weekly)
                except Exception:
                    w = 0
                if w <= 0:
                    continue

                ts_set = allowed_ts_map.get((c_id, s_id), set()) or set()
                a = len(ts_set)

                if a < w:
                    bad_cs_allowed.append(
                        {
                            "class_id": int(c_id),
                            "subject_id": int(s_id),
                            "class_name": class_name_by_id.get(int(c_id), str(c_id)),
                            "subject_name": subject_name_by_id.get(int(s_id), str(s_id)),
                            "weekly": int(w),
                            "allowed": int(a),
                            "margin": int(a) - int(w),
                        }
                    )

            bad_cs_allowed.sort(key=lambda r: (r["margin"], r["allowed"], -r["weekly"]))

            # (2) 固定（spec_triples）と教師禁則の衝突を検出
            #   - TT科目: 全教師がOKでないと矛盾
            #   - 通常科目: 全教師がNGなら矛盾（誰も担当できない）
            bad_fixed_unavail = []
            for (c_id, s_id, ts_id) in (spec_triples or set()):
                c_id = int(c_id)
                s_id = int(s_id)
                ts_id = int(ts_id)

                t_list = list(cs_teachers_map.get((c_id, s_id), []) or [])
                if not t_list:
                    continue

                is_tt = (c_id, s_id) in (team_teach_pairs or set())

                if is_tt:
                    ng = [
                        int(t)
                        for t in t_list
                        if ts_id in (teacher_unavail_ts.get(int(t), set()) or set())
                    ]
                    if ng:
                        bad_fixed_unavail.append(
                            {
                                "class_name": class_name_by_id.get(c_id, str(c_id)),
                                "subject_name": subject_name_by_id.get(s_id, str(s_id)),
                                "ts_id": ts_id,
                                "mode": "team_teach",
                                "teachers_ng": ng,
                            }
                        )
                else:
                    if all(ts_id in (teacher_unavail_ts.get(int(t), set()) or set()) for t in t_list):
                        bad_fixed_unavail.append(
                            {
                                "class_name": class_name_by_id.get(c_id, str(c_id)),
                                "subject_name": subject_name_by_id.get(s_id, str(s_id)),
                                "ts_id": ts_id,
                                "mode": "normal_all_ng",
                                "teachers_ng": [int(t) for t in t_list],
                            }
                        )

            try:
                current_app.logger.warning(
                    "[PRECHECK][CS-ALLOWED] bad=%d sample=%s",
                    len(bad_cs_allowed),
                    bad_cs_allowed[:5],
                )
                current_app.logger.warning(
                    "[PRECHECK][FIXED-UNAVAIL] bad=%d sample=%s",
                    len(bad_fixed_unavail),
                    bad_fixed_unavail[:5],
                )
            except Exception:
                pass

            if bad_cs_allowed or bad_fixed_unavail:
                # 画面に出す要点だけ作る（詳細はログ）
                soft_report = []

                if bad_cs_allowed:
                    r = bad_cs_allowed[0]
                    soft_report.append(
                        f"【確定矛盾】可用コマ不足: {r['class_name']} {r['subject_name']} weekly={r['weekly']} allowed={r['allowed']} (margin={r['margin']})"
                    )
                    soft_report.append(
                        f"（対処）教師禁則/固定/同時展開で allowed が削られ過ぎています。weekly を減らすか、禁則/固定/同時展開を緩めてください。"
                    )

                if bad_fixed_unavail:
                    r = bad_fixed_unavail[0]
                    soft_report.append(
                        f"【確定矛盾】固定×教師禁則: {r['class_name']} {r['subject_name']} ts={r['ts_id']} mode={r['mode']} ng_teachers={r['teachers_ng']}"
                    )
                    soft_report.append(
                        f"（対処）その固定コマを変更するか、該当教師の禁則を解除してください。TT科目は“全員OK”が必要です。"
                    )

                flash(
                    "作成前チェックで確定矛盾を検出しました（可用コマ不足 / 固定×禁則）。ログを確認してください。",
                    "danger",
                )
                if conn:
                    conn.rollback()

                base = build_view_context(sid)
                base["teachers"] = teachers
                base["timeslots"] = timeslots
                base["teacher_unavail_map"] = {}
                base["timeslot_cnt"] = len(timeslots or [])
                base["class_load_rows"] = pre_class_load_rows if "pre_class_load_rows" in locals() else []
                base["show_diagnostics"] = False
                base["soft_report"] = soft_report + [
                    f"可用コマ不足（allowed<weekly）: {len(bad_cs_allowed)}件（ログ: [PRECHECK][CS-ALLOWED]）",
                    f"固定×教師禁則の矛盾: {len(bad_fixed_unavail)}件（ログ: [PRECHECK][FIXED-UNAVAIL]）",
                ]
                return render_template("update_schedules.html", **base)






            # ============================================================
            # ★PRECHECK-0: solver準拠の「作成前チェック」行をここで確定して保持（③で使う）
            # ============================================================
            pre_ts_cnt = None
            pre_class_load_rows = []
            pre_same_time_mismatch_rows = []
            try:
                _st_groups = same_time_groups if "same_time_groups" in locals() else []
                pre_ts_cnt, pre_class_load_rows, pre_same_time_mismatch_rows = build_class_load_summary_solver_aligned(
                    classes=classes,
                    timeslots=timeslots,
                    cs_weekly_map=cs_weekly_map,
                    same_time_groups=_st_groups,
                    selected_subject_rows=_pre_ss_rows if '_pre_ss_rows' in locals() else [],
                )

                # gap != 0 のクラスがあるか（あなたの運用上は diff=0 が前提なので、ここで止める）
                _gap_ng = [r for r in (pre_class_load_rows or []) if int(r.get("gap", 0)) != 0]
                try:
                    current_app.logger.info(
                        "[PRECHECK][LOAD-GAP] nonzero=%d sample=%s",
                        len(_gap_ng),
                        _gap_ng[:5],
                    )
                except Exception:
                    pass

                # ★ここが重要：gap != 0 がある限り、(各時限に何か入れる制約がある場合) 確定で INFEASIBLE になります
                if _gap_ng:
                    flash(
                        "作成前チェックで差(gap)≠0のクラスがあります。まず必修/選択枠の週コマ合計が時限数と一致するようにデータを直してください。",
                        "danger",
                    )
                    if conn:
                        conn.rollback()

                    base = build_view_context(sid)
                    base["teachers"] = teachers
                    base["timeslots"] = timeslots
                    base["teacher_unavail_map"] = {}
                    base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                    base["class_load_rows"] = pre_class_load_rows or []
                    base["show_diagnostics"] = False
                    base["soft_report"] = [
                        f"【要修正】gap≠0 クラスが {len(_gap_ng)} 件あります（ログ: [PRECHECK][LOAD-GAP]）。",
                        "（対処）class_subjects の weekly_classes と、same_time/select_group の構成を見直してください。",
                    ]
                    return render_template("update_schedules.html", **base)

                # same_time 週回数混在（確定矛盾）がある場合も止める
                if pre_same_time_mismatch_rows:
                    flash(
                        "作成前チェックで矛盾を検出しました（same_time 内で週回数が混在）。先に同時制約の構成を直してください。",
                        "danger",
                    )
                    if conn:
                        conn.rollback()

                    base = build_view_context(sid)
                    base["teachers"] = teachers
                    base["timeslots"] = timeslots
                    base["teacher_unavail_map"] = {}
                    base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                    base["class_load_rows"] = pre_class_load_rows or []
                    base["show_diagnostics"] = False
                    first = bad_st[0]
                    msg_lines = [
                        f"【確定矛盾】same_time の共通候補(intersection)が weekly を下回る: {len(bad_st)}件",
                        f"例: gid={first.get('gid')} subtype={first.get('subtype')} required={first.get('required')} inter={first.get('inter_cnt')} margin={first.get('margin')}",
                        "▼同時に置く必要があるメンバー（最大30件）",
                    ]
                    for m in (first.get("members") or [])[:30]:
                        msg_lines.append(f" - {m}")
                    msg_lines.extend([
                        "",
                        "（対処）同時ブロックの各メンバーが同時に置ける時限が足りません。",
                        "  1) 禁則（教師×時限）や固定/連続（もし有効化している場合）を緩める",
                        "  2) 同時ブロックの週回数(weekly)を下げる / メンバーを分割する",
                        "  3) 同時ブロックの対象クラス/科目が誤って混ざっていないか確認する",
                    ])
                    base["soft_report"] = msg_lines

                    return render_template("update_schedules.html", **base)

            except Exception as e:
                # ★握りつぶさない（ここが silent failure の原因になりやすい）
                current_app.logger.exception("[PRECHECK-0] build_class_load_summary_solver_aligned failed: %s", e)




            # -------------------------------------------------------------
            # ★PRECHECK: [SPECIFIC-COLLISION]
            #   固定(specific)が同一クラス×同一時限で衝突していないか
            #   ※「ペア(class_id, subject_id)」が取れる場合はペアを最優先する
            # -------------------------------------------------------------
            try:
                class_name_by_id_d = {
                    int(x["class_id"]): (x.get("class_name") or "")
                    for x in (classes or [])
                    if x.get("class_id") is not None
                }
                # 表示名（なければ subject_name / code など）
                subject_label_by_id_d = {
                    int(x["subject_id"]): (
                        x.get("subject_code")
                        or x.get("display_name")
                        or x.get("subject_name")
                        or str(x.get("subject_id"))
                    )
                    for x in (subjects or [])
                    if x.get("subject_id") is not None
                }

                # (class_id, ts_id) -> {"subs": set(str), "cids": set(int)}
                forced_map = defaultdict(lambda: {"subs": set(), "cids": set()})

                # どの変数があるか（ts_id 判定に使う）
                ts_ids_set = set()
                for ts in (timeslots or []):
                    try:
                        ts_ids_set.add(int(ts.get("timeslot_id")))
                    except Exception:
                        pass

                # 可能なら「グループ形式（pairs を持つ）」を使う
                specific_src = (
                    locals().get("specific_groups")
                    or locals().get("_pre_specific_groups")
                    or locals().get("_pre_specific_rows")
                    or []
                )

                ambiguous = []  # ペアが無く、クラス集合×科目集合の形になっている（総当たりになる）もの

                for g in (specific_src or []):
                    # ---- 1) group形式: {"constraint_id", "ts_id/timeslot_id", "pairs":[(c,s),...]} ----
                    if isinstance(g, dict) and "pairs" in g:
                        cid = int(g.get("constraint_id") or g.get("cid") or 0)
                        ts_id = int(g.get("timeslot_id") or g.get("ts_id") or 0)
                        pairs = g.get("pairs") or []

                        for (c_id, s_id) in pairs:
                            try:
                                c_id = int(c_id); s_id = int(s_id)
                            except Exception:
                                continue
                            key = (c_id, ts_id)
                            forced_map[key]["subs"].add(subject_label_by_id_d.get(s_id) or str(s_id))
                            forced_map[key]["cids"].add(cid)
                        continue

                    # ---- 2) row形式（dict/tuple）: class_id & subject_id が同じ行にあるなら「ペア」として扱う ----
                    cid = 0
                    c_id = None
                    s_id = None
                    ts_id = None

                    if isinstance(g, dict):
                        cid = int(g.get("constraint_id") or g.get("cid") or 0)
                        # よくあるキー名を広めに拾う
                        c_id = g.get("class_id")
                        s_id = g.get("subject_id")
                        ts_id = g.get("timeslot_id") or g.get("ts_id")
                    else:
                        # tuple/list の場合：安全に拾う（ts_id っぽい値を探す）
                        try:
                            arr = list(g)
                        except Exception:
                            arr = []
                        # constraint_id が先頭にあるケース
                        if len(arr) >= 4:
                            cid = int(arr[0] or 0)
                            # 2番目が ts_id っぽい
                            if int(arr[1]) in ts_ids_set:
                                ts_id = int(arr[1])
                                c_id = arr[2]
                                s_id = arr[3]
                        elif len(arr) == 3:
                            # (class_id, subject_id, ts_id) 形式を想定
                            if int(arr[2]) in ts_ids_set:
                                c_id = arr[0]
                                s_id = arr[1]
                                ts_id = arr[2]

                    # ペアとして確定できるなら採用
                    try:
                        if c_id is not None and s_id is not None and ts_id is not None:
                            c_id = int(c_id); s_id = int(s_id); ts_id = int(ts_id)
                            key = (c_id, ts_id)
                            forced_map[key]["subs"].add(subject_label_by_id_d.get(s_id) or str(s_id))
                            forced_map[key]["cids"].add(int(cid or 0))
                            continue
                    except Exception:
                        pass

                    # ここに来るのは「クラス集合」「科目集合」を別々に持つ古い形の可能性
                    # → まとめレコードだと総当たりになって衝突するので、検出して注意喚起
                    if isinstance(g, dict):
                        cls = g.get("class_ids") or []
                        subs = g.get("subject_ids") or []
                        ts_guess = g.get("timeslot_id") or g.get("ts_id")
                        try:
                            ts_guess = int(ts_guess) if ts_guess is not None else None
                        except Exception:
                            ts_guess = None
                        if cls and subs and ts_guess is not None:
                            ambiguous.append({"constraint_id": int(cid or 0), "ts_id": ts_guess, "classes": len(cls), "subjects": len(subs)})

                # 衝突判定（同一class×ts に 2科目以上固定されたら確定矛盾）
                bad = []
                for (c_id, ts_id), v in forced_map.items():
                    subs = sorted(list(v["subs"]))
                    if len(subs) >= 2:
                        bad.append({
                            "class": class_name_by_id_d.get(int(c_id)) or str(c_id),
                            "ts_id": int(ts_id),
                            "subjects": subs,
                            "constraint_ids": sorted(list(v["cids"]))[:10],
                        })

                bad.sort(key=lambda r: (-len(r.get("subjects", [])), r.get("class", ""), r.get("ts_id", 0)))

                if ambiguous:
                    current_app.logger.warning("[PRECHECK][SPECIFIC-AMBIGUOUS] rows=%d sample=%s", len(ambiguous), ambiguous[:5])

                if bad:
                    current_app.logger.error(
                        "[PRECHECK][SPECIFIC-COLLISION] bad=%d sample=%s",
                        len(bad), bad[:3]
                    )
                    flash("作成前チェックで矛盾を検出しました（固定(specific)が同一クラス×同一時限で衝突）。", "danger")
                    if conn:
                        conn.rollback()

                    # 既存の表示処理があるなら、ここはあなたの元コードと同じ返し方でOK
                    base = build_view_context(sid)
                    base["teachers"] = teachers
                    base["timeslots"] = timeslots
                    base["teacher_unavail_map"] = {}
                    base["show_diagnostics"] = False
                    base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                    base["class_load_rows"] = pre_class_load_rows or []
                    base["soft_report"] = [
                        f"【確定矛盾】固定(specific)が同一クラス×同一時限で衝突: {len(bad)}件",
                        f"例: {bad[0]}",
                        "（対処）固定制約の重複を削除するか、片方を別時限に移してください。",
                        "",
                        "※もし「1レコードで複数クラスを固定」したい場合は、constraint_members が (class_id, subject_id) の“ペア”として保存されている必要があります。",
                        "  [PRECHECK][SPECIFIC-AMBIGUOUS] が出る場合、クラス集合×科目集合の総当たりになっているため、1クラスに複数科目固定が発生します。",
                    ]
                    return render_template("update_schedules.html", **base)

                # 衝突なし
                current_app.logger.info("[PRECHECK][SPECIFIC-COLLISION] bad=0")

            except Exception as e:
                current_app.logger.exception("[PRECHECK][SPECIFIC-COLLISION] failed: %s", e)





            # ============================================================
            # ★PRECHECK-1: allowed が weekly を下回る科目を即検出（[PRECHECK][IMPOSSIBLE]）
            # ============================================================
            try:
                worst = []
                neg = []
                for (c_id, s_id), w in (cs_weekly_map or {}).items():
                    w = int(w or 0)
                    allowed = allowed_ts_map.get((c_id, s_id), []) or []
                    margin = len(allowed) - w
                    worst.append((margin, int(c_id), int(s_id), w, len(allowed)))
                    if margin < 0:
                        neg.append((margin, int(c_id), int(s_id), w, len(allowed)))

                worst.sort(key=lambda x: x[0])
                current_app.logger.info("[PRECHECK] cs=%d worst10=%s", len(worst), worst[:10])

                if neg:
                    neg.sort(key=lambda x: x[0])
                    current_app.logger.error("[PRECHECK][IMPOSSIBLE] negative=%s", neg[:10])

                    flash(
                        "作成前チェックで矛盾を検出しました（[PRECHECK][IMPOSSIBLE]）。"
                        "allowed_ts_map の候補数が weekly_classes を下回る科目があります。ログの [PRECHECK][IMPOSSIBLE] を確認してください。",
                        "danger",
                    )
                    if conn:
                        conn.rollback()

                    base = build_view_context(sid)
                    base["teachers"] = teachers
                    base["timeslots"] = timeslots
                    base["teacher_unavail_map"] = {}
                    # ★③：失敗画面でも solver準拠の集計を表示
                    base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                    base["class_load_rows"] = pre_class_load_rows or []
                    base["show_diagnostics"] = False
                    return render_template("update_schedules.html", **base)

            except Exception as e:
                current_app.logger.exception("[PRECHECK-1] failed: %s", e)

            # ============================================================
            # ★PRECHECK-2: same_time の「共通候補(intersection)不足」を検出
            # ============================================================
            try:
                bad_st = []

                # 表示用（あれば）
                class_name_by_id = {int(x["class_id"]): (x.get("class_name") or "") for x in (classes or []) if x.get("class_id") is not None}
                subject_name_by_id = {int(x["subject_id"]): (x.get("display_name") or x.get("subject_name") or "") for x in (subjects or []) if x.get("subject_id") is not None}

                for g in (same_time_groups or []):
                    subtype = (g.get("subtype") or "").strip() or "(blank)"
                    gid = g.get("gid")

                    pairs = []
                    for (c_id, s_id) in (g.get("pairs") or []):
                        try:
                            c_id = int(c_id); s_id = int(s_id)
                        except Exception:
                            continue
                        if (c_id, s_id) in cs_weekly_map:
                            pairs.append((c_id, s_id))

                    if not pairs:
                        continue

                    uniq_pairs = sorted(set(pairs))
                    required = max(int(cs_weekly_map.get(cs_key, 0)) for cs_key in uniq_pairs)

                    inter = None
                    for cs_key in uniq_pairs:
                        ts_set = set(allowed_ts_map.get(cs_key, []) or [])
                        inter = ts_set if inter is None else (inter & ts_set)
                    inter = inter or set()

                    margin = len(inter) - int(required)
                    if margin < 0:
                        mem_disp = []
                        for (c_id, s_id) in uniq_pairs[:30]:
                            cname = class_name_by_id.get(c_id, str(c_id))
                            sname = subject_name_by_id.get(s_id, str(s_id))
                            w = int(cs_weekly_map.get((c_id, s_id), 0))
                            mem_disp.append(f"{cname}:{sname}({w})")

                        bad_st.append({
                            "gid": gid,
                            "subtype": subtype,
                            "required": int(required),
                            "inter_cnt": int(len(inter)),
                            "margin": int(margin),
                            "members": mem_disp,
                            "member_cnt": len(uniq_pairs),
                        })

                bad_st.sort(key=lambda r: r["margin"])

                # ★bad=0でも出して「実行されている」ことを確実にする
                current_app.logger.info(
                    "[PRECHECK][SAME-TIME-INTERSECTION] bad=%d sample=%s",
                    len(bad_st),
                    bad_st[:3],
                )

                if bad_st:
                    flash(
                        "作成前チェックで矛盾を検出しました（same_time の共通候補不足）。"
                        "ログ [PRECHECK][SAME-TIME-INTERSECTION] を確認してください。",
                        "danger",
                    )

                    base = build_view_context(sid)
                    base["teachers"] = teachers
                    base["timeslots"] = timeslots
                    base["teacher_unavail_map"] = {}

                    base["soft_report"] = [
                        f"【確定矛盾】same_time の共通候補(intersection)が weekly を下回る: {len(bad_st)}件",
                        f"例: gid={bad_st[0].get('gid')} subtype={bad_st[0].get('subtype')} required={bad_st[0].get('required')} inter={bad_st[0].get('inter_cnt')} margin={bad_st[0].get('margin')}",
                    ]

                    base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                    base["class_load_rows"] = pre_class_load_rows or []
                    base["show_diagnostics"] = False

                    if conn:
                        conn.rollback()
                    return render_template("update_schedules.html", **base)

            except Exception as e:
                current_app.logger.exception("[PRECHECK-2] failed: %s", e)

            # ============================================================
            # ★連続（consecutive）ハード制約（allowed_ts_map 構築後に実行する）
            # ============================================================
            consecutive_groups = []
            DEBUG_ONLY_CONSECUTIVE_IDS = None  # 例: {348}

            if DEBUG_ENFORCE_CONSECUTIVE:
                consecutive_groups = fetch_consecutive_groups(cursor, sid) or []
                if DEBUG_ONLY_CONSECUTIVE_IDS:
                    consecutive_groups = [
                        g for g in consecutive_groups
                        if int(g.get("constraint_id") or 0) in DEBUG_ONLY_CONSECUTIVE_IDS
                    ]
                add_consecutive_hard(
                    model=model,
                    subject_in_slot=subject_in_slot,
                    timeslots=timeslots,
                    cs_weekly_map=cs_weekly_map,
                    allowed_ts_map=allowed_ts_map,
                    consecutive_groups=consecutive_groups,
                    logger=current_app.logger,
                )

            # === allowed_ts_map / fixed_ts_map を CP-SAT に反映 ===

            # === allowed_ts_map / fixed_ts_map を CP-SAT に反映 ===
            for (c_id, s_id), ts_allowed in (allowed_ts_map or {}).items():
                ts_allowed_set = set(ts_allowed or [])
                for ts in (timeslots or []):
                    ts_id = int(ts["timeslot_id"])
                    key = (c_id, s_id, ts_id)
                    if ts_id not in ts_allowed_set:
                        if key in subject_in_slot:
                            model.Add(subject_in_slot[key] == 0)

            for (c_id, s_id), ts_fixed_set in (fixed_ts_map or {}).items():
                if not ts_fixed_set:
                    continue
                for ts_id in (ts_fixed_set or []):
                    ts_id = int(ts_id)
                    key = (c_id, s_id, ts_id)
                    if key in subject_in_slot:
                        model.Add(subject_in_slot[key] == 1)

            # === 診断：優先度リスト ===
            try:
                cs_priority_list = build_cs_priority_list(cs_weekly_map, allowed_ts_map)
                session["cs_priority_list"] = cs_priority_list
            except Exception as e:
                current_app.logger.exception("[DIAG] build_cs_priority_list failed: %s", e)
                session["cs_priority_list"] = []

            # ============================================================
            # 目的関数（ソフト制約ペナルティを合成）
            # ============================================================
            consecutive_cs_set = set()
            try:
                for g in (consecutive_groups or []):
                    for (cid, sid_, _tid) in (g.get("members") or []):
                        if cid is None or sid_ is None:
                            continue
                        consecutive_cs_set.add((int(cid), int(sid_)))
            except Exception:
                consecutive_cs_set = set()

            def _int_or(v, default):
                try:
                    return int(v)
                except Exception:
                    return default

            w_teacher_spread = _int_or(request.form.get("w_teacher_spread"), session.get("w_teacher_spread", 5))
            w_subject_one_per_day = _int_or(request.form.get("w_subject_one_per_day"), session.get("w_subject_one_per_day", 1))

            w_teacher_spread = max(0, min(30, w_teacher_spread))
            w_subject_one_per_day = max(0, min(10, w_subject_one_per_day))

            session["w_teacher_spread"] = w_teacher_spread
            session["w_subject_one_per_day"] = w_subject_one_per_day
            session.modified = True

            soft_terms = add_soft_preferences(
                model,
                timeslots=timeslots,
                class_subjects=class_subjects,
                cs_teacher_map=cs_teachers_map,
                subject_in_slot=subject_in_slot,
                consecutive_cs_set=consecutive_cs_set,
                weight_teacher_spread=w_teacher_spread,
                weight_subject_one_per_day=w_subject_one_per_day,
                enable_teacher_spread=True,
                enable_subject_one_per_day=True,
            )

            model.Maximize(sum(schedule.values()) - sum(soft_terms))

            # Solve
            solver = cp_model.CpSolver()

            # UIパラメータ（既存）
            try:
                ui_max_time = float(request.form.get("max_time", session.get("max_time", 60.0)))
            except (TypeError, ValueError):
                ui_max_time = 60.0
            try:
                ui_gap_pct = float(request.form.get("gap_pct", session.get("gap_pct", 20.0)))
            except (TypeError, ValueError):
                ui_gap_pct = 20.0
            try:
                ui_workers = int(request.form.get("workers", session.get("workers", 8)))
            except (TypeError, ValueError):
                ui_workers = 8

            ui_seed_raw = request.form.get("seed", session.get("seed", ""))
            use_seed = request.form.get("use_seed", session.get("use_seed", "0")) == "1"

            ui_max_time = max(5.0, min(ui_max_time, 900.0))
            ui_gap_pct = max(0.0, min(ui_gap_pct, 50.0))
            ui_workers = max(1, min(ui_workers, 32))
            relative_gap = ui_gap_pct / 100.0

            session["max_time"] = ui_max_time
            session["gap_pct"] = ui_gap_pct
            session["workers"] = ui_workers
            session["seed"] = ui_seed_raw
            session["use_seed"] = "1" if use_seed else "0"

            solver.parameters.max_time_in_seconds = ui_max_time
            solver.parameters.relative_gap_limit = relative_gap
            solver.parameters.num_search_workers = ui_workers
            solver.parameters.log_search_progress = False
            if use_seed and str(ui_seed_raw).strip():
                try:
                    solver.parameters.random_seed = int(str(ui_seed_raw).strip())
                except ValueError:
                    pass


            ACCEPT_GAP = relative_gap

            try:
                current_app.logger.info(
                    "[SOLVE] start max_time=%.1fs workers=%d gap=%.3f use_seed=%s seed=%s",
                    ui_max_time, ui_workers, relative_gap, use_seed, ui_seed_raw
                )
            except Exception:
                pass

            status = solver.Solve(model)
            current_app.logger.info("TT solve status = %s", status)



            # ============================================================
            # ★★★③：INFEASIBLEのrenderでも pre_* を必ず表示する（表示ズレ根絶）
            # ============================================================
            if status not in (cp_model.OPTIMAL, cp_model.FEASIBLE):
                flash("時間割の作成に失敗しました（INFEASIBLE）。制約の組み合わせを確認してください。", "danger")
                if conn:
                    conn.rollback()

                # === [INPUT-COUNT][POST-INFEASIBLE] はあなたの既存があればそのままでOK ===

                base = build_view_context(sid)
                base["teachers"] = teachers
                base["timeslots"] = timeslots
                base["teacher_unavail_map"] = {}
                base["show_diagnostics"] = False

                # ★③：失敗画面でも solver準拠の集計を必ず表示（pre_* が無ければ最後に作る）
                try:
                    if pre_ts_cnt is None or (pre_class_load_rows is None):
                        _st_groups = same_time_groups if "same_time_groups" in locals() else []
                        pre_ts_cnt, pre_class_load_rows, _ = build_class_load_summary_solver_aligned(
                            classes=classes,
                            timeslots=timeslots,
                            cs_weekly_map=cs_weekly_map,
                            same_time_groups=_st_groups,
                            selected_subject_rows=_pre_ss_rows if '_pre_ss_rows' in locals() else [],
                        )
                except Exception as e:
                    current_app.logger.exception("[③] rebuild pre_class_load_rows failed: %s", e)

                base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                base["class_load_rows"] = pre_class_load_rows or []

                return render_template("update_schedules.html", **base)






            # === 保存可否判定（既存ロジック維持）===
            obj = solver.ObjectiveValue()
            best = solver.BestObjectiveBound()
            gap = None
            if best not in (math.inf, -math.inf):
                gap = max(0.0, (best - obj) / max(1.0, abs(obj)))

            is_success = (status == cp_model.OPTIMAL) or (status == cp_model.FEASIBLE and (gap is None or gap <= ACCEPT_GAP))

            if not is_success:
                if conn:
                    conn.rollback()
                msg = "時間割の作成に失敗しました。制約を見直してください。"
                if gap is not None:
                    msg += f"（最適性ギャップ: {gap:.2%} > 許容 {ACCEPT_GAP:.2%}）"
                flash(msg, "danger")

                base = build_view_context(sid)
                base["teachers"] = teachers
                base["timeslots"] = timeslots
                base["teacher_unavail_map"] = {}
                base["show_diagnostics"] = False
                base["soft_report"] = []
                base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                base["class_load_rows"] = pre_class_load_rows or []
                return render_template("update_schedules.html", **base)

            # === [STEP3] 入力テーブルが作成中に変化していたら中断（保護）=========
            input_counts_after = {
                "class_subjects": _count_one("SELECT COUNT(*) AS n FROM class_subjects WHERE school_id=%s", (sid,)),
                "class_subject_teachers": _count_one("SELECT COUNT(*) AS n FROM class_subject_teachers WHERE school_id=%s", (sid,)),
                "selected_subjects": _count_one("SELECT COUNT(*) AS n FROM selected_subjects WHERE school_id=%s", (sid,)),
            }

            if input_counts_after != input_counts_before:
                try:
                    current_app.logger.error("[INPUT-COUNT][CHANGED] before=%s after=%s", input_counts_before, input_counts_after)
                except Exception:
                    pass

                if conn:
                    conn.rollback()

                flash(
                    "作成中に入力データ（class_subjects / selected_subjects 等）が変化しました。"
                    "入力テーブルを書き換える処理が混入している可能性があります。"
                    "サーバログの [INPUT-COUNT][CHANGED] を確認してください。",
                    "danger",
                )

                base = build_view_context(sid)
                base["teachers"] = teachers
                base["timeslots"] = timeslots
                base["teacher_unavail_map"] = {}
                base["show_diagnostics"] = False
                base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                base["class_load_rows"] = pre_class_load_rows or []
                return render_template("update_schedules.html", **base)
            # === [STEP3] END ====================================================

            # ============================================================
            # ★診断モード：解が出ても保存しない
            # ============================================================
            if DEBUG_ISOLATE_ONLY:

                if conn:
                    conn.rollback()

                flash("（診断）解は見つかりましたが、DEBUG_ISOLATE_ONLY=True のため保存せず停止しました。", "warning")

                base = build_view_context(sid)
                base["teachers"] = teachers
                base["timeslots"] = timeslots
                base["teacher_unavail_map"] = {}
                base["show_diagnostics"] = False
                base["timeslot_cnt"] = pre_ts_cnt if pre_ts_cnt is not None else len(timeslots or [])
                base["class_load_rows"] = pre_class_load_rows or []
                base["soft_report"] = ["（診断）FEASIBLE になりました。DEBUG_DISABLE を切り替えて原因制約を確定してください。"]
                return render_template("update_schedules.html", **base)

            # 1) delete
            cursor.execute("DELETE FROM schedules WHERE school_id=%s", (sid,))

            inserted = 0
            for (c_id, s_id), t_list in (cs_teachers_map or {}).items():
                for ts in (timeslots or []):
                    ts_id = int(ts["timeslot_id"])
                    if solver.Value(subject_in_slot[(c_id, s_id, ts_id)]) == 1:
                        for t_id in (t_list or []):
                            if solver.Value(schedule[(c_id, s_id, int(t_id), ts_id)]) == 1:
                                cursor.execute(
                                    """
                                    INSERT INTO schedules (school_id, class_id, subject_id, teacher_id, timeslot_id)
                                    VALUES (%s, %s, %s, %s, %s)
                                    """,
                                    (sid, c_id, s_id, int(t_id), ts_id),
                                )
                                inserted += 1

            conn.commit()
            current_app.logger.info("[SAVE] schedules inserted=%d", inserted)

        finally:
            try:
                if cursor:
                    cursor.close()
            except Exception:
                pass
            try:
                if conn:
                    conn.close()
            except Exception:
                pass

        return redirect(url_for("schedules.update_schedules", school_id=sid))



    # ---------------------------------
    # GET：表示（あなたが戻した表示ブロックを基本維持）
    # ---------------------------------
    else:
        conn = None
        cursor = None
        ctx = {}

        try:
            conn = get_db_connection()
            cursor = get_dict_cursor(conn)

            sid = _sid()
            if sid is None:
                flash("school_id が未設定です。", "danger")
                base = build_view_context(None)
                base["soft_report"] = session.pop("soft_report", [])

                # ★設計方針とは異なる提案ですが：未定義変数で落ちないようにする
                class_load_rows = []
                timeslot_cnt = 0
                show_diagnostics = False

                return render_template(
                    "update_schedules.html",
                    **base,
                    class_load_rows=class_load_rows,
                    timeslot_cnt=timeslot_cnt,
                    show_diagnostics=show_diagnostics,
                )

            cursor.execute("SELECT * FROM timeslots WHERE school_id=%s ORDER BY day_of_week, number", (sid,))
            timeslots = cursor.fetchall() or []

            cursor.execute("SELECT * FROM teachers WHERE school_id=%s ORDER BY number", (sid,))
            teachers = cursor.fetchall() or []

            # unavailable（灰色表示）
            cursor.execute(
                """
                SELECT
                    cm.teacher_id AS teacher_id,
                    c.timeslot_id AS timeslot_id
                FROM constraints AS c
                JOIN constraint_members AS cm
                  ON cm.constraint_id = c.id
                WHERE c.school_id = %s 
                  AND c.is_enabled = 1 
                  AND c.type = 'unavailable'
                  AND cm.teacher_id IS NOT NULL
                  AND c.timeslot_id IS NOT NULL
                """,
                (sid,),
            )
            _unav_rows = cursor.fetchall() or []

            teacher_unavail_pairs = {
                (int(r["teacher_id"]), int(r["timeslot_id"]))
                for r in _unav_rows
                if r.get("teacher_id") is not None and r.get("timeslot_id") is not None
            }
            teacher_unavail_map = {pair: True for pair in teacher_unavail_pairs}

            overview = compute_overview(cursor, sid)
            same_time_count = int(overview.get("same_time_count", 0))
            total_slots = int(overview.get("total_slots", 0))
            adjusted_total = int(overview.get("required_slots", 0))
            adjustment_details = overview.get("adjustment_details", []) or []

            show_diagnostics = False

            cs_priority_list = session.get("cs_priority_list") or []
            same_time_diag_rows = session.get("same_time_diag_rows") or []
            if not show_diagnostics:
                cs_priority_list = []
                same_time_diag_rows = []


            # ★作成前チェック（solver入力準拠版）
            #   - selected_subjects(group_name) があればそれを優先して「選択時間」を算出
            #   - 無い場合のみ same_time から推定

            # classes（表示用）
            cursor.execute(
                "SELECT class_id, class_name FROM classes WHERE school_id=%s ORDER BY class_id",
                (sid,),
            )
            _classes_rows = cursor.fetchall() or []

            # subjects（ログ/表示補助）
            cursor.execute(
                "SELECT subject_id, subject_name FROM subjects WHERE school_id=%s",
                (sid,),
            )
            _subjects_rows = cursor.fetchall() or []

            class_name_by_id = {
                int(r["class_id"]): (r.get("class_name") or "")
                for r in (_classes_rows or [])
                if r.get("class_id") is not None
            }
            subject_name_by_id = {
                int(r["subject_id"]): (r.get("subject_name") or "")
                for r in (_subjects_rows or [])
                if r.get("subject_id") is not None
            }

            # class_subjects → cs_weekly_map（同一(class,subject)が複数行あっても max にする）
            cursor.execute(
                "SELECT class_id, subject_id, weekly_classes FROM class_subjects WHERE school_id=%s",
                (sid,),
            )
            _cs_rows = cursor.fetchall() or []

            cs_weekly_map = {}
            for r in (_cs_rows or []):
                try:
                    c_id = int(r.get("class_id"))
                    s_id = int(r.get("subject_id"))
                    w = int(r.get("weekly_classes") or 0)
                except Exception:
                    continue
                key = (c_id, s_id)
                cs_weekly_map[key] = max(int(cs_weekly_map.get(key, 0) or 0), int(w))

            # same_time
            try:
                _same_time_groups = fetch_same_time_groups(cursor, sid) or []
            except Exception:
                _same_time_groups = []

            # selected_subjects（group_name）
            _pre_ss_rows = []
            try:
                cursor.execute(
                    """
                    SELECT class_id, subject_id, TRIM(group_name) AS group_name
                      FROM selected_subjects
                     WHERE school_id=%s
                       AND group_name IS NOT NULL
                       AND TRIM(group_name) <> ''
                    """,
                    (sid,),
                )
                _pre_ss_rows = cursor.fetchall() or []
                current_app.logger.info("[PRECHECK][SS] rows=%d", len(_pre_ss_rows))
            except Exception as e:
                current_app.logger.exception("[PRECHECK][SS] fetch failed: %s", e)
                _pre_ss_rows = []

            timeslot_cnt, class_load_rows, _mismatch_rows = build_class_load_summary_solver_aligned(
                classes=_classes_rows,
                timeslots=timeslots,
                cs_weekly_map=cs_weekly_map,
                same_time_groups=_same_time_groups,
                class_name_by_id=class_name_by_id,
                subject_name_by_id=subject_name_by_id,
                selected_subject_rows=_pre_ss_rows,
            )

            try:
                if _mismatch_rows:
                    current_app.logger.warning(
                        "[PRECHECK][SAME-TIME-W-MISMATCH] count=%d sample=%s",
                        len(_mismatch_rows),
                        _mismatch_rows[:3],
                    )
            except Exception:
                pass
            show_diagnostics = False

            ctx = build_view_context(sid)
            ctx.update({
                "teachers": teachers,
                "timeslots": timeslots,
                "teacher_unavail_map": teacher_unavail_map,
                "same_time_count": same_time_count,
                "total_slots": total_slots,
                "required_slots": adjusted_total,
                "weekly_list": [],
                "adjustment_details": adjustment_details,
                "school_id": sid,

                "show_diagnostics": show_diagnostics,
                "cs_priority_list": cs_priority_list,
                "same_time_diag_rows": same_time_diag_rows,

                "timeslot_cnt": timeslot_cnt,
                "class_load_rows": class_load_rows,
            })

            ctx["soft_report"] = session.pop("soft_report", [])
            return render_template("update_schedules.html", **ctx)

        except Exception as e:
            flash(f"表示時エラー: {e}", "danger")
            tmp_ctx = dict(ctx)
            tmp_ctx.setdefault("teachers", [])
            tmp_ctx.setdefault("timeslots", [])
            tmp_ctx.setdefault("cell_dict", {})
            tmp_ctx.setdefault("total_slots", 0)
            tmp_ctx.setdefault("required_slots", 0)
            tmp_ctx.setdefault("same_time_count", 0)
            tmp_ctx.setdefault("teacher_unavail_map", {})
            tmp_ctx.setdefault("weekly_list", [])
            tmp_ctx.setdefault("adjustment_details", [])
            tmp_ctx.setdefault("school_id", sid if "sid" in locals() else None)
            tmp_ctx.setdefault("soft_report", [])

            tmp_ctx.setdefault("show_diagnostics", False)
            tmp_ctx.setdefault("cs_priority_list", [])
            tmp_ctx.setdefault("same_time_diag_rows", [])

            tmp_ctx.setdefault("timeslot_cnt", len(tmp_ctx.get("timeslots", []) or []))
            tmp_ctx.setdefault("class_load_rows", [])

            return render_template("update_schedules.html", **tmp_ctx)

        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()



# =========================================
# 教員CSV（school_idで限定）
# =========================================
@schedules_bp.route('/export_teachers_csv', methods=['GET'])
#★★★設計方針5: 生成結果のCSV出力（運用・配布を想定）
def export_teachers_csv():
    sid = _sid()
    if sid is None:
        flash("school_id が未設定です。", "danger")
        return redirect(url_for('schedules.update_schedules'))
    conn = None
    cursor = None
    try:
        conn = get_db_connection()
        cursor = get_dict_cursor(conn)
        cursor.execute("SELECT * FROM teachers WHERE school_id=%s ORDER BY number", (sid,))
        teachers = cursor.fetchall()
        cursor.execute("SELECT * FROM timeslots WHERE school_id=%s ORDER BY timeslot_id", (sid,))
        timeslots = cursor.fetchall()

        sql = """
        SELECT s.teacher_id, s.timeslot_id,
               t.teacher_name, t.number,
               c.class_name,
               COALESCE(NULLIF(sub.display_name, ''), sub.subject_name) AS display_name,
               ts.title
          FROM schedules s
          JOIN teachers  t  ON s.teacher_id = t.teacher_id  AND t.school_id=%s
          JOIN classes   c  ON s.class_id   = c.class_id    AND c.school_id=%s
          JOIN subjects  sub ON s.subject_id = sub.subject_id AND sub.school_id=%s
          JOIN timeslots ts ON s.timeslot_id = ts.timeslot_id AND ts.school_id=%s
         WHERE s.school_id=%s
         ORDER BY t.number, ts.timeslot_id
        """

        cursor.execute(sql, (sid, sid, sid, sid, sid))
        schedule_rows = cursor.fetchall()
        cell_dict = {}
        for row in schedule_rows:
            tid = row['teacher_id']
            tsid = row['timeslot_id']
            cname = row['class_name']
            sname = row['display_name']
            disp = f"{cname}{sname}"
            if (tid, tsid) not in cell_dict:
                cell_dict[(tid, tsid)] = disp
            else:
                cell_dict[(tid, tsid)] += ", " + disp
        output = io.StringIO()
        writer = csv.writer(output, lineterminator='\n')
        header = ["Teacher"] + [ts["title"] for ts in timeslots]
        writer.writerow(header)
        for t in teachers:
            row_data = [t["teacher_name"]]
            for slot in timeslots:
                key = (t["teacher_id"], slot["timeslot_id"])
                val = cell_dict.get(key, "")
                row_data.append(val)
            writer.writerow(row_data)
        csv_content = output.getvalue()
        csv_with_bom = "\ufeff" + csv_content
        resp = make_response(csv_with_bom)
        resp.headers["Content-Disposition"] = "attachment; filename=teachers_timeslot.csv"
        resp.headers["Content-Type"] = "text/csv; charset=utf-8"
        return resp
    except Exception as e:
        flash(f"エラーが発生しました: {e}", "danger")
        return redirect(url_for('schedules.update_schedules', school_id=sid))
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

# =========================================
# クラスCSV（school_idで限定）
# =========================================
@schedules_bp.route('/export_classes_csv', methods=['GET'])
#★★★設計方針5: 生成結果のCSV出力（運用・配布を想定）
def export_classes_csv():
    sid = _sid()
    if sid is None:
        flash("school_id が未設定です。", "danger")
        return redirect(url_for('schedules.update_schedules'))
    conn = None
    cursor = None
    try:
        conn = get_db_connection()
        cursor = get_dict_cursor(conn)

        # 1. クラス一覧を取得（行見出し用）
        cursor.execute("SELECT * FROM classes WHERE school_id=%s ORDER BY class_name", (sid,))
        classes = cursor.fetchall()


        # 2. 時限一覧を取得（列見出し用）
        cursor.execute("SELECT * FROM timeslots WHERE school_id=%s ORDER BY timeslot_id", (sid,))
        timeslots = cursor.fetchall()

        # 3. 時間割データを取得（display_name 優先）
        sql = """
        SELECT
            s.class_id,
            s.timeslot_id,
            COALESCE(NULLIF(sub.display_name, ''), sub.subject_name) AS display_name
          FROM schedules s
          JOIN subjects sub
            ON s.subject_id = sub.subject_id
           AND sub.school_id = %s
         WHERE s.school_id = %s
         ORDER BY s.class_id, s.timeslot_id
        """
        cursor.execute(sql, (sid, sid))
        schedule_rows = cursor.fetchall()

        # 4. クラス×時限ごとにレコードをまとめる
        cell_dict = {}
        for row in schedule_rows:
            key = (row['class_id'], row['timeslot_id'])
            cell_dict.setdefault(key, []).append(row)

        # 5. CSV作成
        output = io.StringIO()
        writer = csv.writer(output, lineterminator='\n')

        # ヘッダー行: 最初のセルは「クラス名」、以降は各時限のタイトル
        header = ["クラス名"] + [ts["title"] for ts in timeslots]
        writer.writerow(header)

        # 各クラスごとに行を作成
        for cl in classes:
            row_data = [cl["class_name"]]
            for ts in timeslots:
                key = (cl["class_id"], ts["timeslot_id"])
                if key in cell_dict:
                    records = cell_dict[key]
                    cell_value = (
                        records[0]["display_name"]
                        if len(records) == 1
                        else ", ".join(r["display_name"] for r in records)
                    )
                else:
                    cell_value = ""
                row_data.append(cell_value)
            writer.writerow(row_data)

        csv_content = output.getvalue()
        csv_with_bom = "\ufeff" + csv_content

        resp = make_response(csv_with_bom)
        resp.headers["Content-Disposition"] = "attachment; filename=classes_timeslot.csv"
        resp.headers["Content-Type"] = "text/csv; charset=utf-8"
        return resp

    except Exception as e:
        flash(f"エラーが発生しました: {e}", "danger")
        return redirect(url_for('schedules.update_schedules', school_id=sid))
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

